'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _asyncGenerator2 = require('babel-runtime/helpers/asyncGenerator');

var _asyncGenerator3 = _interopRequireDefault(_asyncGenerator2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _map2 = require('babel-runtime/core-js/map');

var _map3 = _interopRequireDefault(_map2);

var _uniq2 = require('lodash/uniq');

var _uniq3 = _interopRequireDefault(_uniq2);

var _pick2 = require('lodash/pick');

var _pick3 = _interopRequireDefault(_pick2);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _merge2 = require('lodash/merge');

var _merge3 = _interopRequireDefault(_merge2);

var _map4 = require('lodash/map');

var _map5 = _interopRequireDefault(_map4);

var _last2 = require('lodash/last');

var _last3 = _interopRequireDefault(_last2);

var _isString2 = require('lodash/isString');

var _isString3 = _interopRequireDefault(_isString2);

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

var _cloneDeepWith2 = require('lodash/cloneDeepWith');

var _cloneDeepWith3 = _interopRequireDefault(_cloneDeepWith2);

var _cloneDeep2 = require('lodash/cloneDeep');

var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);

var _querystring = require('querystring');

var _querystring2 = _interopRequireDefault(_querystring);

var _events = require('events');

var _hmacSha = require('crypto-js/hmac-sha256');

var _hmacSha2 = _interopRequireDefault(_hmacSha);

var _encHex = require('crypto-js/enc-hex');

var _encHex2 = _interopRequireDefault(_encHex);

var _common = require('@webex/common');

var _webexCore = require('@webex/webex-core');

var _helperImage = require('@webex/helper-image');

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

var _convoError = require('./convo-error');

var _shareActivity = require('./share-activity');

var _shareActivity2 = _interopRequireDefault(_shareActivity);

var _activityThreadOrdering = require('./activity-thread-ordering');

var _activities = require('./activities');

var _constants = require('./constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CLUSTER_SERVICE = process.env.WEBEX_CONVERSATION_CLUSTER_SERVICE || _constants.DEFAULT_CLUSTER_SERVICE; /*!
                                                                                                             * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
                                                                                                             */

var DEFAULT_CLUSTER_IDENTIFIER = process.env.WEBEX_CONVERSATION_DEFAULT_CLUSTER || _constants.DEFAULT_CLUSTER + ':' + CLUSTER_SERVICE;

var idToUrl = new _map3.default();

var getConvoLimit = function getConvoLimit() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var limit = void 0;

  if (options.conversationsLimit) {
    limit = {
      value: options.conversationsLimit,
      name: 'conversationsLimit'
    };
  }

  return limit;
};

var Conversation = _webexCore.WebexPlugin.extend({
  namespace: 'Conversation',

  /**
   * @param {String} cluster the cluster containing the id
   * @param {UUID} [id] the id of the conversation.
   *  If empty, just return the base URL.
   * @returns {String} url of the conversation
   */
  getUrlFromClusterId: function getUrlFromClusterId() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$cluster = _ref.cluster,
        cluster = _ref$cluster === undefined ? 'us' : _ref$cluster,
        id = _ref.id;

    var clusterId = cluster === 'us' ? DEFAULT_CLUSTER_IDENTIFIER : cluster;

    // Determine if cluster has service name (non-US clusters from hydra do not)
    if (clusterId.split(':').length < 4) {
      // Add Service to cluster identifier
      clusterId = cluster + ':' + CLUSTER_SERVICE;
    }

    var _ref2 = this.webex.internal.services.getServiceFromClusterId({ clusterId: clusterId }) || {},
        url = _ref2.url;

    if (!url) {
      throw Error('Could not find service for cluster [' + cluster + ']');
    }

    return id ? url + '/conversations/' + id : url;
  },


  /**
   * @param {Object} conversation
   * @param {Object} object
   * @param {Object} activity
   * @returns {Promise}
   */
  acknowledge: function acknowledge(conversation, object, activity) {
    var _this = this;

    var url = this.getConvoUrl(conversation);
    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: url });

    if (!(0, _isObject3.default)(object)) {
      return _promise2.default.reject(new Error('`object` must be an object'));
    }

    return this.prepare(activity, {
      verb: 'acknowledge',
      target: this.prepareConversation(convoWithUrl),
      object: {
        objectType: 'activity',
        id: object.id,
        url: object.url
      }
    }).then(function (a) {
      return _this.submit(a);
    });
  },


  /**
   * Adds a participant to a conversation
   * @param {Object} conversation
   * @param {Object|string} participant
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @returns {Promise<Activity>}
   */
  add: function add(conversation, participant, activity) {
    var _this2 = this;

    var url = this.getConvoUrl(conversation);
    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: url });

    return this.webex.internal.user.asUUID(participant, { create: true }).then(function (id) {
      return _this2.prepare(activity, {
        verb: 'add',
        target: _this2.prepareConversation(convoWithUrl),
        object: {
          id: id,
          objectType: 'person'
        },
        kmsMessage: {
          method: 'create',
          uri: '/authorizations',
          resourceUri: '<KRO>',
          userIds: [id]
        }
      }).then(function (a) {
        return _this2.submit(a);
      });
    });
  },


  /**
   * Creates a conversation
   * @param {Object} params
   * @param {Array<Participant>} params.participants
   * @param {Array<File>} params.files
   * @param {string} params.comment
   * @param {string} params.html
   * @param {Object} params.displayName
   * @param {Object} options
   * @param {Boolean} options.allowPartialCreation
   * @param {Boolean} options.forceGrouped
   * @param {Boolean} options.skipOneOnOneFetch skips checking 1:1 exists before creating conversation
   * @returns {Promise<Conversation>}
   */
  create: function create(params) {
    var _this3 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!params.participants || params.participants.length === 0) {
      return _promise2.default.reject(new Error('`params.participants` is required'));
    }

    return _promise2.default.all(params.participants.map(function (participant) {
      return _this3.webex.internal.user.asUUID(participant, { create: true })
      // eslint-disable-next-line arrow-body-style
      .catch(function (err) {
        return options.allowPartialCreation ? undefined : _promise2.default.reject(err);
      });
    })).then(function (participants) {
      participants.unshift(_this3.webex.internal.device.userId);
      participants = (0, _uniq3.default)(participants);

      var validParticipants = participants.filter(function (participant) {
        return participant;
      });

      params.participants = validParticipants;

      // check if original participants list was to create a 1:1
      if (participants.length === 2 && !(options && options.forceGrouped)) {
        if (!params.participants[1]) {
          return _promise2.default.reject(new _convoError.InvalidUserCreation());
        }

        if (options.skipOneOnOneFetch) {
          return _this3._createOneOnOne(params);
        }

        return _this3._maybeCreateOneOnOneThenPost(params, options);
      }

      return _this3._createGrouped(params, options);
    }).then(function (c) {
      idToUrl.set(c.id, c.url);

      if (!params.files) {
        return c;
      }

      return _this3.webex.internal.conversation.share(c, params.files).then(function (a) {
        c.activities.items.push(a);

        return c;
      });
    });
  },


  /**
   * @private
   * generate a deterministic HMAC for a reaction
   * @param {Object} displayName displayName of reaction we are sending
   * @param {Object} parent parent activity of reaction
   * @returns {Promise<HMAC>}
   */
  createReactionHmac: function createReactionHmac(displayName, parent) {
    // not using webex.internal.encryption.getKey() because the JWK it returns does not have a 'k'
    // property. we need jwk.k to correctly generate the HMAC

    return this.webex.internal.encryption.unboundedStorage.get(parent.encryptionKeyUrl).then(function (keyString) {
      var key = JSON.parse(keyString);
      // when we stringify this object, keys must be in this order to generate same HMAC as
      // desktop clients
      var formatjwk = { k: key.jwk.k, kid: key.jwk.kid, kty: key.jwk.kty };

      var source = '' + (0, _stringify2.default)(formatjwk) + parent.id + displayName;

      var hmac = _encHex2.default.stringify((0, _hmacSha2.default)(source, parent.id));

      return _promise2.default.resolve(hmac);
    });
  },


  /**
   * @typedef {Object} ReactionPayload
   * @property {Object} actor
   * @property {string} actor.objectType
   * @property {string} actor.id
   * @property {string} objectType
   * @property {string} verb will be either add' or 'delete'
   * @property {Object} target
   * @property {string} target.id
   * @property {string} target.objectType
   * @property {Object} object this will change on delete vs. add
   * @property {string} object.id present in delete case
   * @property {string} object.objectType 'activity' in delete case, 'reaction2' in add case
   * @property {string} object.displayName must be 'celebrate', 'heart', 'thumbsup', 'smiley', 'haha', 'confused', 'sad'
   * @property {string} object.hmac
   */

  /**
   * @private
   * send add or delete reaction to convo service
   * @param {Object} conversation
   * The payload to send a reaction
   * @param {ReactionPayload} reactionPayload
   * @returns {Promise<Activity>}
   */
  sendReaction: function sendReaction(conversation, reactionPayload) {
    var _this4 = this;

    var url = this.getConvoUrl(conversation);
    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: url });

    if (!(0, _isObject3.default)(reactionPayload)) {
      return _promise2.default.reject(new Error('`object` must be an object'));
    }

    return this.prepare(reactionPayload, {
      target: this.prepareConversation(convoWithUrl),
      object: (0, _pick3.default)(reactionPayload, 'id', 'url', 'objectType')
    }).then(function (act) {
      return _this4.submit(act);
    });
  },


  /**
   * delete a reaction
   * @param {Object} conversation
   * @param {Object} reactionId
   * @returns {Promise<Activity>}
   */
  deleteReaction: function deleteReaction(conversation, reactionId) {
    var deleteReactionPayload = {
      actor: { objectType: 'person', id: this.webex.internal.device.userId },
      object: {
        id: reactionId,
        objectType: 'activity'
      },
      objectType: 'activity',
      target: {
        id: conversation.id,
        objectType: 'conversation'
      },
      verb: 'delete'
    };

    return this.sendReaction(conversation, deleteReactionPayload);
  },


  /**
   * create a reaction
   * @param {Object} conversation
   * @param {Object} displayName must be 'celebrate', 'heart', 'thumbsup', 'smiley', 'haha', 'confused', 'sad'
   * @param {Object} activity activity object from convo we are reacting to
   * @returns {Promise<Activity>}
   */
  addReaction: function addReaction(conversation, displayName, activity) {
    var _this5 = this;

    return this.createReactionHmac(displayName, activity).then(function (hmac) {
      var addReactionPayload = {
        actor: { objectType: 'person', id: _this5.webex.internal.device.userId },
        target: {
          id: conversation.id,
          objectType: 'conversation'
        },
        verb: 'add',
        objectType: 'activity',
        parent: {
          type: 'reaction',
          id: activity.id
        },
        object: {
          objectType: 'reaction2',
          displayName: displayName,
          hmac: hmac
        }
      };

      return _this5.sendReaction(conversation, addReactionPayload);
    });
  },


  /**
   * delete content
   * @param {Object} conversation
   * @param {Object} object
   * @param {Object} activity
   * @returns {Promise}
   */
  delete: function _delete(conversation, object, activity) {
    var _this6 = this;

    var url = this.getConvoUrl(conversation);
    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: url });

    if (!(0, _isObject3.default)(object)) {
      return _promise2.default.reject(new Error('`object` must be an object'));
    }

    return this.prepare(activity, {
      verb: 'delete',
      target: this.prepareConversation(convoWithUrl),
      object: (0, _pick3.default)(object, 'id', 'url', 'objectType')
    }).then(function (a) {
      return _this6.submit(a);
    });
  },


  /**
   * Downloads the file specified in item.scr or item.url
   * @param {Object} item
   * @param {Object} item.scr
   * @param {string} item.url
   * @param {Object} options
   * @param {Object} options.headers
   * @param {boolean} options.shouldNotAddExifData
   * @returns {Promise<File>}
   */
  download: function download(item) {
    var _this7 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var isEncrypted = Boolean(item.scr && item.scr.key);
    var shunt = new _events.EventEmitter();
    var promise = void 0;

    if (isEncrypted) {
      promise = this.webex.internal.encryption.download(item.scr, item.options);
    } else if (item.scr && item.scr.loc) {
      promise = this._downloadUnencryptedFile(item.scr.loc, options);
    } else {
      promise = this._downloadUnencryptedFile(item.url, options);
    }

    promise = promise.on('progress', function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return shunt.emit.apply(shunt, ['progress'].concat(args));
    }).then(function (res) {
      if (options.shouldNotAddExifData) {
        return res;
      }

      return (0, _helperImage.readExifData)(item, res);
    }).then(function (file) {
      _this7.logger.info('conversation: file downloaded');

      if (item.displayName && !file.name) {
        file.name = item.displayName;
      }

      if (!file.type && item.mimeType) {
        file.type = item.mimeType;
      }

      return file;
    });

    (0, _common.proxyEvents)(shunt, promise);

    return promise;
  },


  /**
   * Downloads an unencrypted file
   * @param {string} uri
   * @param {Object} options
   * @param {Ojbect} options.headers
   * @returns {Promise<File>}
   */
  _downloadUnencryptedFile: function _downloadUnencryptedFile(uri) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    (0, _assign2.default)(options, {
      uri: uri,
      responseType: 'buffer'
    });

    var promise = this.request(options).then(function (res) {
      return res.body;
    });

    (0, _common.proxyEvents)(options.download, promise);

    return promise;
  },


  /**
   * Helper method that expands a set of parameters into an activty object
   * @param {string} verb
   * @param {Object} object
   * @param {Object} target
   * @param {Object|string} actor
   * @returns {Object}
   */
  expand: function expand(verb, object, target, actor) {
    var activity = {
      actor: actor,
      objectType: 'activity',
      verb: verb
    };

    if (!actor) {
      actor = this.webex.internal.device.userId;
    }

    if ((0, _isString3.default)(actor)) {
      activity.actor = {
        objectType: 'person',
        id: actor
      };
    }

    if (object) {
      activity.object = object;
    }

    if (target) {
      activity.target = target;
    }

    return activity;
  },


  /**
  * Gets an array of activities with an array of activity URLS
  * @param {Array} activityUrls
  * @param {Object} options
  * @param {String} options.cluster cluster where the activities are located
  * @param {String} options.url base convo url where the activities are located
  * @returns {Promise<Object>} Resolves with the activities
  */
  bulkActivitiesFetch: function bulkActivitiesFetch(activityUrls) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var cluster = void 0,
        url = void 0;

    if (typeof options === 'string') {
      cluster = options;
    } else {
      cluster = options.cluster;
      url = options.url;
    }

    var resource = 'bulk_activities_fetch';
    var params = {
      method: 'POST',
      body: {
        activityUrls: activityUrls
      }
    };

    if (url) {
      var uri = url + '/' + resource;

      (0, _assign2.default)(params, {
        uri: uri
      });
    } else if (cluster) {
      var _uri = this.getUrlFromClusterId({ cluster: cluster }) + '/' + resource;

      (0, _assign2.default)(params, {
        uri: _uri
      });
    } else {
      (0, _assign2.default)(params, {
        api: 'conversation',
        resource: resource
      });
    }

    return this.webex.request(params).then(function (res) {
      var activitiesArr = [];

      if (res.body.multistatus) {
        res.body.multistatus.forEach(function (statusData) {
          if (statusData.status === '200' && statusData.data && statusData.data.activity) {
            activitiesArr.push(statusData.data.activity);
          }
        });
      }

      return activitiesArr;
    });
  },


  /**
   * Fetches a single conversation
   * @param {Object} conversation
   * @param {String} [conversation.url] The URL where the conversation is located.
   * @param {String|UUID} [conversation.user] The user to look up in the conversation service
   *   If specified, the user lookup will take precedence over the url lookup
   * @param {Object} options
   * @returns {Promise<Conversation>}
   */
  get: function get(conversation) {
    var _this8 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var user = conversation.user;

    var uri = void 0;

    try {
      uri = !user ? this.getConvoUrl(conversation) : '';
    } catch (err) {
      return _promise2.default.reject(Error(err));
    }

    var params = {
      qs: (0, _assign2.default)({
        uuidEntryFormat: true,
        personRefresh: true,
        activitiesLimit: 0,
        includeConvWithDeletedUserUUID: false,
        includeParticipants: false
      }, (0, _omit3.default)(options, 'id', 'user', 'url'))
    };

    // Default behavior is to set includeParticipants=false,
    // which makes the payload lighter by removing participant info.
    // If the caller explicitly sets the participantAckFilter or
    // participantsLimit, we don't want that default setting.
    if ('participantAckFilter' in options || 'participantsLimit' in options) {
      delete params.qs.includeParticipants;
    }

    return _promise2.default.resolve(user ? this.webex.internal.user.asUUID(user) : null).then(function (userId) {
      if (userId) {
        (0, _assign2.default)(params, {
          service: 'conversation',
          resource: 'conversations/user/' + userId
        });
      } else {
        params.uri = uri;
      }

      return _this8.request(params);
    }).then((0, _common.tap)(function (_ref3) {
      var body = _ref3.body;
      var id = body.id,
          url = body.url;


      _this8._recordUUIDs(body);
      idToUrl.set(id, url);
    })).then(function (res) {
      return res.body;
    });
  },


  /**
   * Leaves the conversation or removes the specified user from the specified
   * conversation
   * @param {Object} conversation
   * @param {Object|string} participant If not specified, defaults to current
   * user
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @returns {Promise<Activity>}
   */
  leave: function leave(conversation, participant, activity) {
    var _this9 = this;

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return _promise2.default.resolve().then(function () {
      if (!participant) {
        participant = _this9.webex.internal.device.userId;
      }

      return _this9.webex.internal.user.asUUID(participant).then(function (id) {
        return _this9.prepare(activity, {
          verb: 'leave',
          target: _this9.prepareConversation(convoWithUrl),
          object: {
            id: id,
            objectType: 'person'
          },
          kmsMessage: {
            method: 'delete',
            uri: '<KRO>/authorizations?' + _querystring2.default.stringify({ authId: id })
          }
        });
      });
    }).then(function (a) {
      return _this9.submit(a);
    });
  },


  /**
   * Lists a set of conversations. By default does not fetch activities or
   * participants
   * @param {Object} options
   * @param {boolean} options.deferDecrypt - when true, deferDecrypt tells the
   * payload transformer to normalize (but not decrypt) each received
   * conversation. Instead, the received conversations will each have a bound
   * decrypt method that can be executed at the consumer's leisure
   * @returns {Promise<Array<Conversation>>}
   */
  list: function list() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    return this._list({
      service: 'conversation',
      resource: 'conversations',
      qs: (0, _omit3.default)(options, 'deferDecrypt'),
      deferDecrypt: options.deferDecrypt,
      limit: getConvoLimit(options)
    }).then(function (results) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(results), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var convo = _step.value;

          idToUrl.set(convo.id, convo.url);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return results;
    });
  },


  /**
   * Paginates through a set of conversations. By default does not fetch activities or
   * participants
   * @param {Object} options
   * @param {boolean} options.deferDecrypt - when true, deferDecrypt tells the
   * payload transformer to normalize (but not decrypt) each received
   * conversation. Instead, the received conversations will each have a bound
   * decrypt method that can be executed at the consumer's leisure
   * @param {Page} options.page - After the first result has been returned to a consumer,
   * you can pass the Page back to the sdk to get the next list of results.
   * @returns {Promise<Array<Conversation>>}
   */
  paginate: function () {
    var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
      var _this10 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var queryOptions, reqOptions;
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!options.page) {
                _context.next = 4;
                break;
              }

              if (!(!options.page.links || !options.page.links.next)) {
                _context.next = 3;
                break;
              }

              throw new Error('No link to follow for the provided page');

            case 3:
              return _context.abrupt('return', this.request({
                url: options.page.links.next
              }).then(function (res) {
                return { page: new _webexCore.Page(res, _this10.webex) };
              }));

            case 4:

              // No page - so this is the first request to kick off the pagination process
              queryOptions = (0, _assign2.default)({
                personRefresh: true,
                uuidEntryFormat: true,
                activitiesLimit: 0,
                participantsLimit: 0,
                paginate: true
              }, (0, _omit3.default)(options, ['deferDecrypt', 'url']));
              reqOptions = {
                qs: queryOptions,
                deferDecrypt: options.deferDecrypt,
                limit: getConvoLimit(options)
              };

              // if options.url is present we likely received one or more additional urls due to federation. In this case
              // we need to initialize pagination against that url instead of the default home cluster

              if (options.url) {
                reqOptions.uri = options.url + '/conversations';
              } else {
                reqOptions.service = 'conversation';
                reqOptions.resource = 'conversations';
              }

              return _context.abrupt('return', this.request(reqOptions).then(function (res) {
                var response = {
                  page: new _webexCore.Page(res, _this10.webex)
                };

                if (res.body && res.body.additionalUrls) {
                  response.additionalUrls = res.body.additionalUrls;
                }

                return response;
              }));

            case 8:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function paginate() {
      return _ref4.apply(this, arguments);
    }

    return paginate;
  }(),


  /**
   * Lists the conversations the current user has left. By default does not
   * fetch activities or participants
   * @param {Object} options
   * @returns {Promise<Array<Conversation>>}
   */
  listLeft: function listLeft(options) {
    return this._list({
      service: 'conversation',
      resource: 'conversations/left',
      qs: options,
      limit: getConvoLimit(options)
    }).then(function (results) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(results), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var convo = _step2.value;

          idToUrl.set(convo.id, convo.url);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return results;
    });
  },


  /**
   * List activities for the specified conversation
   * @param {Object} options
   * @param {String} options.conversationUrl URL to the conversation
   * @returns {Promise<Array<Activity>>}
   */
  listActivities: function listActivities(options) {
    return this._listActivities((0, _assign2.default)(options, { resource: 'activities' }));
  },


  /**
   * @typedef QueryOptions
   * @param {number} [limit] The limit of child activities that can be returned per request
   * @param {boolean} [latestActivityFirst] Sort order for the child activities
   * @param {boolean} [includeParentActivity] Enables the parent activity to be returned in the activity list
   * @param {string} [sinceDate] Get all child activities after this date
   * @param {string} [maxDate] Get all child activities before this date
   * @param {boolean} [latestActivityFirst] Sort order for the child activities
   * @param {string} [activityType] The type of children to return the parents of, a null value here returns parents of all types of children.
   * The value is one of 'reply', 'edit', 'cardAction', 'reaction', 'reactionSummary', 'reactionSelfSummary'
   */

  /**
   * Get all parent ids for a conversation.
   * @param {string} conversationUrl conversation URL.
   * @param {QueryOptions} [query] object containing query string values to be appended to the url
   * @returns {Promise<Array<String>>}
   */
  listParentActivityIds: function () {
    var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(conversationUrl, query) {
      var params, response;
      return _regenerator2.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              params = {
                method: 'GET',
                url: conversationUrl + '/parents',
                qs: query
              };
              _context2.next = 3;
              return this.request(params);

            case 3:
              response = _context2.sent;
              return _context2.abrupt('return', response.body);

            case 5:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function listParentActivityIds(_x10, _x11) {
      return _ref5.apply(this, arguments);
    }

    return listParentActivityIds;
  }(),


  /**
   * Returns a list of _all_ child activities for a given parentId within a given conversation
   * @param {object} [options = {}]
   * @param {string} [options.conversationUrl] targeted conversation URL
   * @param {string} [options.activityParentId] parent id of edit activities or thread activities
   * @param {QueryOptions} [options.query] object containing query string values to be appended to the url
   * @returns {Promise<Array>}
   */
  listAllChildActivitiesByParentId: function () {
    var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var conversationUrl, activityParentId, query, activityType, initialResponse, page, items, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, activity;

      return _regenerator2.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              conversationUrl = options.conversationUrl, activityParentId = options.activityParentId, query = options.query;
              activityType = query.activityType;
              _context3.next = 4;
              return this.listChildActivitiesByParentId(conversationUrl, activityParentId, activityType, query);

            case 4:
              initialResponse = _context3.sent;
              page = new _webexCore.Page(initialResponse, this.webex);
              items = [].concat((0, _toConsumableArray3.default)(page.items));

            case 7:
              if (!page.hasNext()) {
                _context3.next = 32;
                break;
              }

              _context3.next = 10;
              return page.next();

            case 10:
              page = _context3.sent;
              _iteratorNormalCompletion3 = true;
              _didIteratorError3 = false;
              _iteratorError3 = undefined;
              _context3.prev = 14;

              for (_iterator3 = (0, _getIterator3.default)(page); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                activity = _step3.value;

                items.push(activity);
              }
              _context3.next = 22;
              break;

            case 18:
              _context3.prev = 18;
              _context3.t0 = _context3['catch'](14);
              _didIteratorError3 = true;
              _iteratorError3 = _context3.t0;

            case 22:
              _context3.prev = 22;
              _context3.prev = 23;

              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }

            case 25:
              _context3.prev = 25;

              if (!_didIteratorError3) {
                _context3.next = 28;
                break;
              }

              throw _iteratorError3;

            case 28:
              return _context3.finish(25);

            case 29:
              return _context3.finish(22);

            case 30:
              _context3.next = 7;
              break;

            case 32:

              // reverse list if needed (see _list for precedent)
              if (items.length && (0, _last3.default)(items).published < items[0].published) {
                items.reverse();
              }

              return _context3.abrupt('return', items);

            case 34:
            case 'end':
              return _context3.stop();
          }
        }
      }, _callee3, this, [[14, 18, 22, 30], [23,, 25, 29]]);
    }));

    function listAllChildActivitiesByParentId() {
      return _ref6.apply(this, arguments);
    }

    return listAllChildActivitiesByParentId;
  }(),


  /**
   * Return a list of child activities with a given conversation, parentId and other constraints.
   * @param {string} conversationUrl targeted conversation URL
   * @param {string} activityParentId parent id of edit activities or thread activities
   * @param {string} activityType type of child activity to return
   * The value is one of 'reply', 'edit', 'cardAction', 'reaction', 'reactionSummary', 'reactionSelfSummary'
   * @param {QueryOptions} [query = {}] object containing query string values to be appended to the url
   * @returns {Promise<Array>}
   */
  listChildActivitiesByParentId: function () {
    var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(conversationUrl, activityParentId, activityType) {
      var query = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var finalQuery, params;
      return _regenerator2.default.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              finalQuery = (0, _extends3.default)({}, query, {
                activityType: activityType
              });
              params = {
                method: 'GET',
                url: conversationUrl + '/parents/' + activityParentId,
                qs: finalQuery
              };
              return _context4.abrupt('return', this.request(params));

            case 3:
            case 'end':
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function listChildActivitiesByParentId(_x14, _x15, _x16) {
      return _ref7.apply(this, arguments);
    }

    return listChildActivitiesByParentId;
  }(),


  /**
   * Return an array of reactionSummary and reactionSelfSummary objects
   * @param {string} conversationUrl targeted conversation URL
   * @param {string} activityParentId parent id of reaction activities
   * @param {QueryOptions} query object representing query parameters to pass to convo endpoint
   * @returns {Promise<Array>}
   */
  getReactionSummaryByParentId: function () {
    var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(conversationUrl, activityParentId, query) {
      var _ref9, body, reactionObjects;

      return _regenerator2.default.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.request({
                method: 'GET',
                url: conversationUrl + '/activities/' + activityParentId,
                qs: query
              });

            case 2:
              _ref9 = _context5.sent;
              body = _ref9.body;
              reactionObjects = body.children ? body.children.filter(function (child) {
                return child.type === 'reactionSelfSummary' || child.type === 'reactionSummary';
              }) : [];
              return _context5.abrupt('return', reactionObjects);

            case 6:
            case 'end':
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function getReactionSummaryByParentId(_x17, _x18, _x19) {
      return _ref8.apply(this, arguments);
    }

    return getReactionSummaryByParentId;
  }(),


  /**
   * Lists activities in which the current user was mentioned
   * @param {Object} options
   * @returns {Promise<Array<Activity>>}
   */
  listMentions: function listMentions(options) {
    return this._list({
      service: 'conversation',
      resource: 'mentions',
      qs: (0, _omit3.default)(options, 'mentions')
    });
  },


  /**
   * Mutes the mentions of a conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  muteMentions: function muteMentions(conversation, activity) {
    return this.tag(conversation, {
      tags: ['MENTION_NOTIFICATIONS_OFF']
    }, activity);
  },


  /**
   * Mutes the messages of a conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  muteMessages: function muteMessages(conversation, activity) {
    return this.tag(conversation, {
      tags: ['MESSAGE_NOTIFICATIONS_OFF']
    }, activity);
  },


  /**
   * @param {Object} conversation
   * @param {Object} inputs
   * @param {Object} parentActivity
   * @param {Object} activity
   * @returns {Promise}
   */
  cardAction: function cardAction(conversation, inputs, parentActivity) {
    var _this11 = this;

    var activity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    activity.parent = {
      id: parentActivity.id,
      type: 'cardAction'
    };

    return this.prepare(activity, {
      verb: 'cardAction',
      target: this.prepareConversation(convoWithUrl),
      object: (0, _assign2.default)({ objectType: 'submit' }, inputs)
    }).then(function (a) {
      return _this11.submit(a);
    });
  },


  /**
   * Posts a message to a conversation
   * @param {Object} conversation
   * @param {Object|string} message if string, treated as plaintext; if object,
   * assumed to be object property of `post` activity
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @returns {Promise<Activity>}
   */
  post: function post(conversation, message, activity) {
    var _this12 = this;

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    if ((0, _isString3.default)(message)) {
      message = {
        displayName: message
      };
    }

    return this.prepare(activity, {
      verb: 'post',
      target: this.prepareConversation(convoWithUrl),
      object: (0, _assign2.default)({ objectType: 'comment' }, message)
    }).then(function (a) {
      return _this12.submit(a);
    });
  },
  prepareConversation: function prepareConversation(conversation) {
    return (0, _defaults3.default)((0, _pick3.default)(conversation, 'id', 'url', 'objectType', 'defaultActivityEncryptionKeyUrl', 'kmsResourceObjectUrl'), {
      objectType: 'conversation'
    });
  },
  prepare: function prepare(activity, params) {
    var _this13 = this;

    params = params || {};
    activity = activity || {};

    return _promise2.default.resolve(activity.prepare ? activity.prepare(params) : activity).then(function (act) {
      (0, _defaults3.default)(act, {
        verb: params.verb,
        kmsMessage: params.kmsMessage,
        objectType: 'activity',
        clientTempId: _uuid2.default.v4(),
        actor: _this13.webex.internal.device.userId
      });

      // Workaround because parent is a reserved props in Ampersand
      if (activity.parentActivityId && activity.activityType || activity.parent && activity.parent.id && activity.parent.type) {
        act.parent = {
          id: activity.parentActivityId || activity.parent.id,
          type: activity.activityType || activity.parent.type
        };
      }

      if ((0, _isString3.default)(act.actor)) {
        act.actor = {
          objectType: 'person',
          id: act.actor
        };
      }

      ['actor', 'object'].forEach(function (key) {
        if (params[key]) {
          act[key] = act[key] || {};
          (0, _defaults3.default)(act[key], params[key]);
        }
      });

      if (params.target) {
        (0, _merge3.default)(act, {
          target: (0, _pick3.default)(params.target, 'id', 'url', 'objectType', 'kmsResourceObjectUrl', 'defaultActivityEncryptionKeyUrl')
        });
      }

      ['object', 'target'].forEach(function (key) {
        if (act[key] && act[key].url && !act[key].id) {
          act[key].id = act[key].url.split('/').pop();
        }
      });

      ['actor', 'object', 'target'].forEach(function (key) {
        if (act[key] && !act[key].objectType) {
          // Reminder: throwing here because it's the only way to get out of
          // this loop in event of an error.
          throw new Error('`act.' + key + '.objectType` must be defined');
        }
      });

      if (act.object && act.object.content && !act.object.displayName) {
        return _promise2.default.reject(new Error('Cannot submit activity object with `content` but no `displayName`'));
      }

      return act;
    });
  },


  /**
   * Handles incoming conversation.activity mercury messages
   * @param {Event} event
   * @returns {Promise}
   */
  processActivityEvent: function processActivityEvent(event) {
    return this.webex.transform('inbound', event).then(function () {
      return event;
    });
  },


  /**
   * Removes all mute-related tags
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  removeAllMuteTags: function removeAllMuteTags(conversation, activity) {
    return this.untag(conversation, {
      tags: ['MENTION_NOTIFICATIONS_OFF', 'MENTION_NOTIFICATIONS_ON', 'MESSAGE_NOTIFICATIONS_OFF', 'MESSAGE_NOTIFICATIONS_ON']
    }, activity);
  },


  /**
   * Creates a ShareActivty for the specified conversation
   * @param {Object} conversation
   * @param {Object} activity
   * @returns {ShareActivty}
   */
  makeShare: function makeShare(conversation, activity) {
    // if we pass activity as null then it does not take care of the
    // clientTempId created by the web-client while making the provisional
    // activity, hence we need to pass the activity which was created by the
    // web-client. This fixes the issue where the image activities do not come
    // back properly oriented from the server since the clientTempId is missing
    return _shareActivity2.default.create(conversation, activity, this.webex);
  },


  /**
   * Assigns an avatar to a room
   * @param {Object} conversation
   * @param {File} avatar
   * @returns {Promise<Activity>}
   */
  assign: function assign(conversation, avatar) {
    var _this14 = this;

    if ((avatar.size || avatar.length) > 1024 * 1024) {
      return _promise2.default.reject(new Error('Room avatars must be less than 1MB'));
    }

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return _promise2.default.resolve().then(function () {
      var activity = _shareActivity2.default.create(conversation, null, _this14.webex);

      activity.enableThumbnails = false;
      activity.add(avatar);

      return _this14.prepare(activity, {
        target: _this14.prepareConversation(convoWithUrl)
      });
    }).then(function (a) {
      // yes, this seems a little hacky; will likely be resolved as a result
      // of #213
      a.verb = 'assign';

      return _this14.submit(a);
    });
  },


  /**
   * Get url from convo object. If there isn't one, get it from the cache
   *
   * @param {String} url The location of the conversation
   * @param {UUID} id If there is no url, fall back to id to lookup in cache or with cluster
   * @param {String} cluster Used with id to lookup url
   * @param {UUID} generalConversationUuid If this is a team, the id of the general conversation
   * @param {Object} conversations If this is a team, the list of conversations in the team
   * @returns {String} url for the specific convo
   */
  getConvoUrl: function getConvoUrl(_ref10) {
    var id = _ref10.id,
        url = _ref10.url,
        cluster = _ref10.cluster,
        conversations = _ref10.conversations,
        generalConversationUuid = _ref10.generalConversationUuid;

    if (generalConversationUuid) {
      // This is a Team
      // Because Convo doesn't have an endpoint for the team URL
      // we have to use the general convo URL.
      var generalConvo = conversations.items.find(function (convo) {
        return convo.id === generalConversationUuid;
      });

      return generalConvo.url;
    }

    if (url) {
      return url;
    }

    if (id) {
      if (cluster) {
        return this.getUrlFromClusterId({ cluster: cluster, id: id });
      }
      this.logger.warn('You should be using the `url` instead of the `id` property');
      var relatedUrl = idToUrl.get(id);

      if (!relatedUrl) {
        throw Error('Could not find the `url` from the given `id`');
      }

      return relatedUrl;
    }

    throw Error('The space needs a `url` property');
  },


  /**
   * Sets the typing status of the current user in a conversation
   *
   * @param {Object} conversation
   * @param {Object} options
   * @param {boolean} options.typing
   * @returns {Promise}
   */
  updateTypingStatus: function updateTypingStatus(conversation, options) {
    if (!conversation.id) {
      if (conversation.url) {
        conversation.id = conversation.url.split('/').pop();
      } else {
        return _promise2.default.reject(new Error('conversation: could not identify conversation'));
      }
    }

    var eventType = void 0;

    if (options.typing) {
      eventType = 'status.start_typing';
    } else {
      eventType = 'status.stop_typing';
    }

    var url = this.getConvoUrl(conversation);
    var resource = 'status/typing';
    var params = {
      method: 'POST',
      body: {
        conversationId: conversation.id,
        eventType: eventType
      },
      url: url + '/' + resource
    };

    return this.request(params);
  },


  /**
   * Shares files to the specified conversation
   * @param {Object} conversation
   * @param {ShareActivity|Array<File>} activity
   * @returns {Promise<Activity>}
   */
  share: function share(conversation, activity) {
    var _this15 = this;

    if ((0, _isArray3.default)(activity)) {
      activity = {
        object: {
          files: activity
        }
      };
    }

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    if (!(activity instanceof _shareActivity2.default)) {
      activity = _shareActivity2.default.create(convoWithUrl, activity, this.webex);
    }

    return this.prepare(activity, {
      target: this.prepareConversation(convoWithUrl)
    }).then(function (a) {
      return _this15.submit(a);
    });
  },


  /**
   * Submits an activity to the conversation service
   * @param {Object} activity
   * @param {String} [endpoint] endpoint to submit activity. If empty, find in activity
   * @returns {Promise<Activity>}
   */
  submit: function submit(activity, endpoint) {
    var _this16 = this;

    var url = endpoint || this.getConvoUrl(activity.target);
    var resource = activity.verb === 'share' ? 'content' : 'activities';
    var params = {
      method: 'POST',
      body: activity,
      qs: {
        personRefresh: true
      },
      url: url + '/' + resource
    };

    if (activity.verb === 'share') {
      (0, _assign2.default)(params.qs, {
        transcode: true,
        async: false
      });
    }
    /**
     * helper to cloneDeepWith for copying instance function
     * @param {Object|String|Symbol|Array|Date} value (recursive value to clone from params)
     * @returns {Object|null}
     */
    // eslint-disable-next-line consistent-return
    var customActivityCopy = function customActivityCopy(value) {
      var files = params.body.object.files;


      if (files && value && files.items.length > 0 && value.constructor === files.items[0].scr.constructor) {
        var copySrc = (0, _cloneDeep3.default)(value);

        copySrc.toJWE = value.toJWE;
        copySrc.toJSON = value.toJSON;

        return copySrc;
      }
    };
    var cloneActivity = (0, _cloneDeepWith3.default)(params, customActivityCopy);

    // triggers user-activity to reset logout timer
    this.webex.trigger('user-activity');

    return this.request(params).then(function (res) {
      return res.body;
    }).catch(function (error) {
      // handle when key need to rotate
      if (error.body && error.body.errorCode === _constants.KEY_ROTATION_REQUIRED) {
        cloneActivity.body.target.defaultActivityEncryptionKeyUrl = null;
        _this16.request(cloneActivity);
      } else if (error.body && (error.body.errorCode === _constants.KEY_ALREADY_ROTATED || error.body.errorCode === _constants.ENCRYPTION_KEY_URL_MISMATCH)) {
        // handle when key need to update
        _this16.webex.request({
          method: 'GET',
          api: 'conversation',
          resource: 'conversations/' + params.body.target.id
        }).then(function (res) {
          cloneActivity.body.target.defaultActivityEncryptionKeyUrl = res.body.defaultActivityEncryptionkeyUrl;
          _this16.request(cloneActivity);
        });
      } else {
        throw error;
      }
    });
  },

  /**
   * Remove the avatar from a room
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise}
   */
  unassign: function unassign(conversation, activity) {
    var _this17 = this;

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return this.prepare(activity, {
      verb: 'unassign',
      target: this.prepareConversation(convoWithUrl),
      object: {
        objectType: 'content',
        files: {
          items: []
        }
      }
    }).then(function (a) {
      return _this17.submit(a);
    });
  },


  /**
   * Mutes the mentions of a conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  unmuteMentions: function unmuteMentions(conversation, activity) {
    return this.tag(conversation, {
      tags: ['MENTION_NOTIFICATIONS_ON']
    }, activity);
  },


  /**
   * Mutes the messages of a conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  unmuteMessages: function unmuteMessages(conversation, activity) {
    return this.tag(conversation, {
      tags: ['MESSAGE_NOTIFICATIONS_ON']
    }, activity);
  },


  /**
   * Update an existing activity
   * @param {Object} conversation
   * @param {Object} object
   * @param {Object} activity
   * @returns {Promise}
   */
  update: function update(conversation, object, activity) {
    var _this18 = this;

    if (!(0, _isObject3.default)(object)) {
      return _promise2.default.reject(new Error('`object` must be an object'));
    }

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return this.prepare(activity, {
      verb: 'update',
      target: this.prepareConversation(convoWithUrl),
      object: object
    }).then(function (a) {
      return _this18.submit(a);
    });
  },


  /**
   * Sets a new key for the conversation
   * @param {Object} conversation
   * @param {Key|string} key (optional)
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @returns {Promise<Activity>}
   */
  updateKey: function updateKey(conversation, key, activity) {
    var _this19 = this;

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return this.get(convoWithUrl, {
      activitiesLimit: 0,
      includeParticipants: true
    }).then(function (c) {
      return _this19._updateKey(c, key, activity);
    });
  },


  /**
   * Sets a new key for the conversation
   * @param {Object} conversation
   * @param {Key|string} key (optional)
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @private
   * @returns {Promise<Activity>}
   */
  _updateKey: function _updateKey(conversation, key, activity) {
    var _this20 = this;

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return _promise2.default.resolve(key || this.webex.internal.encryption.kms.createUnboundKeys({ count: 1 })).then(function (keys) {
      var k = (0, _isArray3.default)(keys) ? keys[0] : keys;
      var params = {
        verb: 'updateKey',
        target: _this20.prepareConversation(convoWithUrl),
        object: {
          defaultActivityEncryptionKeyUrl: k.uri,
          objectType: 'conversation'
        }
      };

      // Reminder: the kmsResourceObjectUrl is only usable if there is
      // defaultActivityEncryptionKeyUrl.
      // Valid defaultActivityEncryptionKeyUrl start with 'kms:'
      if (convoWithUrl.kmsResourceObjectUrl && convoWithUrl.kmsResourceObjectUrl.startsWith('kms:')) {
        params.kmsMessage = {
          method: 'update',
          resourceUri: '<KRO>',
          uri: k.uri
        };
      } else {
        params.kmsMessage = {
          method: 'create',
          uri: '/resources',
          userIds: (0, _map5.default)(convoWithUrl.participants.items, 'id'),
          keyUris: [k.uri]
        };
      }

      return _this20.prepare(activity, params).then(function (a) {
        return _this20.submit(a);
      });
    });
  },


  /**
   * @param {Object} payload
   * @param {Object} options
   * @private
   * @returns {Promise<Activity>}
   */
  _create: function _create(payload) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return this.request({
      method: 'POST',
      service: 'conversation',
      resource: 'conversations',
      body: payload,
      qs: {
        forceCreate: options.allowPartialCreation
      }
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * @param {Object} params
   * @param {Object} options
   * @private
   * @returns {Promise}
   */
  _createGrouped: function _createGrouped(params, options) {
    return this._create(this._prepareConversationForCreation(params), options);
  },


  /**
   * @param {Object} params
   * @param {Object} options
   * @private
   * @returns {Promise}
   */
  _createOneOnOne: function _createOneOnOne(params) {
    var payload = this._prepareConversationForCreation(params);

    payload.tags = ['ONE_ON_ONE'];

    return this._create(payload);
  },


  /**
   * Get the current conversation url.
   *
   * @returns {Promise<string>} - conversation url
   */
  getConversationUrl: function getConversationUrl() {
    var _this21 = this;

    this.logger.info('conversation: getting the conversation service url');

    var convoUrl = this.webex.internal.services.get('conversation');

    // Validate if the conversation url exists in the services plugin and
    // resolve with its value.
    if (convoUrl) {
      return _promise2.default.resolve(convoUrl);
    }

    // Wait for the postauth catalog to update and then try to retrieve the
    // conversation service url again.
    return this.webex.internal.waitForCatalog('postauth').then(function () {
      return _this21.webex.internal.services.get('conversation');
    }).catch(function (error) {
      _this21.logger.warn('conversation: unable to get conversation url', error.message);

      return _promise2.default.reject(error);
    });
  },


  /**
   * @param {Object} conversation
   * @private
   * @returns {Promise}
   */
  _inferConversationUrl: function _inferConversationUrl(conversation) {
    var _this22 = this;

    if (conversation.id) {
      return this.webex.internal.feature.getFeature('developer', 'web-high-availability').then(function (haMessagingEnabled) {
        if (haMessagingEnabled) {
          // recompute conversation URL each time as the host may have changed
          // since last usage
          return _this22.getConversationUrl().then(function (url) {
            conversation.url = url + '/conversations/' + conversation.id;

            return conversation;
          });
        }
        if (!conversation.url) {
          return _this22.getConversationUrl().then(function (url) {
            conversation.url = url + '/conversations/' + conversation.id;
            /* istanbul ignore else */
            if (process.env.NODE_ENV !== 'production') {
              _this22.logger.warn('conversation: inferred conversation url from conversation id; please pass whole conversation objects to Conversation methods');
            }

            return conversation;
          });
        }

        return _promise2.default.resolve(conversation);
      });
    }

    return _promise2.default.resolve(conversation);
  },


  /**
   * @param {Object} options
   * @param {String} options.conversationUrl URL to the conversation
   * @param {String} options.resource The URL resource to hit for a list of objects
   * @private
   * @returns {Promise<Array<Activity>>}
   */
  _listActivities: function _listActivities(options) {
    var id = options.conversationId;
    var url = this.getConvoUrl({ url: options.conversationUrl, id: id });
    var resource = options.resource;


    return this._list({
      qs: (0, _omit3.default)(options, 'resource'),
      url: url + '/' + resource
    });
  },


  /**
   * common interface for facade of generator functions
   * @typedef {object} IGeneratorResponse
   * @param {boolean} done whether there is more to fetch
   * @param {any} value the value yielded or returned by generator
   */

  /**
   * @param {object} options
   * @param {string} options.conversationId
   * @param {string} options.conversationUrl,
   * @param {boolean} options.includeChildren, If set to true, parent activities will be enhanced with child objects
   * @param {number} options.minActivities how many activities to return in first batch
   * @param {?string} [options.queryType] one of older, newer, mid. defines which direction to fetch
   * @param {?object} [options.search] server activity to use as search middle date
   *
   * @returns {object}
   * returns three functions:
   *
   * getOlder - gets older activities than oldest fetched
   *
   * getNewer - gets newer activities than newest fetched
   *
   * jumpToActivity - gets searched-for activity and surrounding activities
   */
  listActivitiesThreadOrdered: function listActivitiesThreadOrdered(options) {
    var _this23 = this;

    var conversationUrl = options.conversationUrl,
        conversationId = options.conversationId;


    if (!conversationUrl && !conversationId) {
      throw new Error('must provide a conversation URL or conversation ID');
    }

    var url = this.getConvoUrl({ url: conversationUrl, id: conversationId });

    var baseOptions = (0, _extends3.default)({}, (0, _omit3.default)(options, ['conversationUrl', 'conversationId']), { url: url });

    var olderOptions = (0, _extends3.default)({}, baseOptions, { queryType: _activities.OLDER });

    var threadOrderer = this._listActivitiesThreadOrdered(baseOptions);

    /**
     * gets queried activity and surrounding activities
     * calling this function creates a new generator instance, losing the previous instance's internal state
     * this ensures that jumping to older and newer activities is relative to a single set of timestamps, not many
     * @param {object} searchObject activity object from convo
     * @returns {IGeneratorResponse}
     */
    var jumpToActivity = function () {
      var _ref11 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6(searchObject) {
        var newUrl, searchOptions, _ref12, searchResults;

        return _regenerator2.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (searchObject) {
                  _context6.next = 2;
                  break;
                }

                throw new Error('Search must be an activity object from conversation service');

              case 2:
                newUrl = searchObject.target && searchObject.target.url;

                if (newUrl) {
                  _context6.next = 5;
                  break;
                }

                throw new Error('Search object must have a target url!');

              case 5:
                searchOptions = (0, _extends3.default)({}, baseOptions, { url: newUrl, queryType: _activities.MID, search: searchObject
                });


                threadOrderer = _this23._listActivitiesThreadOrdered(searchOptions);

                _context6.next = 9;
                return threadOrderer.next(searchOptions);

              case 9:
                _ref12 = _context6.sent;
                searchResults = _ref12.value;
                return _context6.abrupt('return', {
                  done: true,
                  value: searchResults
                });

              case 12:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, _this23);
      }));

      return function jumpToActivity(_x22) {
        return _ref11.apply(this, arguments);
      };
    }();

    /**
     * gets older activities than oldest fetched
     * @returns {IGeneratorResponse}
     */
    var getOlder = function () {
      var _ref13 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7() {
        var _ref14, _ref14$value, value, oldestInBatch, moreActivitiesExist;

        return _regenerator2.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return threadOrderer.next(olderOptions);

              case 2:
                _ref14 = _context7.sent;
                _ref14$value = _ref14.value;
                value = _ref14$value === undefined ? [] : _ref14$value;
                oldestInBatch = value[0] && value[0].activity;
                moreActivitiesExist = oldestInBatch && (0, _activities.getActivityType)(oldestInBatch) !== _activities.ACTIVITY_TYPES.CREATE;
                return _context7.abrupt('return', {
                  done: !moreActivitiesExist,
                  value: value
                });

              case 8:
              case 'end':
                return _context7.stop();
            }
          }
        }, _callee7, _this23);
      }));

      return function getOlder() {
        return _ref13.apply(this, arguments);
      };
    }();

    /**
     * gets newer activities than newest fetched
     * @returns {IGeneratorResponse}
     */
    var getNewer = function () {
      var _ref15 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8() {
        var newerOptions, _ref16, value;

        return _regenerator2.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                newerOptions = (0, _extends3.default)({}, baseOptions, { queryType: _activities.NEWER });
                _context8.next = 3;
                return threadOrderer.next(newerOptions);

              case 3:
                _ref16 = _context8.sent;
                value = _ref16.value;
                return _context8.abrupt('return', {
                  done: !value.length,
                  value: value
                });

              case 6:
              case 'end':
                return _context8.stop();
            }
          }
        }, _callee8, _this23);
      }));

      return function getNewer() {
        return _ref15.apply(this, arguments);
      };
    }();

    return {
      jumpToActivity: jumpToActivity,
      getNewer: getNewer,
      getOlder: getOlder
    };
  },


  /**
    * Represents reactions to messages
    * @typedef {object} Reaction
    * @property {object} activity reaction2summary server activity object
    */

  /**
   * Represents a root (parent, with or without children) activity, along with any replies and reactions
   * @typedef {object} Activity
   * @property {object} activity server activity object
   * @property {Reaction} reactions
   * @property {Reaction} reactionSelf
   */

  /**
   * @generator
   * @method
   * @async
   * @private
   * @param {object} options
   * @param {string} options.url
   * @param {boolean} options.includeChildren, If set to true, parent activities will be enhanced with child objects
   * @param {string} [options.minActivities] how many activities to return in first batch
   * @param {string} [options.queryType] one of older, newer, mid. defines which direction to fetch
   * @param {object} [options.search] server activity to use as search middle date
   *
   * @yields {Activity[]}
   *
   * @returns {void}
   */
  _listActivitiesThreadOrdered: function _listActivitiesThreadOrdered() {
    var _this24 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return _asyncGenerator3.default.wrap( /*#__PURE__*/_regenerator2.default.mark(function _callee9() {
      var _options$minActivitie, minActivities, _options$queryType, queryType, convoUrl, _options$search, search, includeChildren, _bookendManager, setBookends, getNewestAct, getOldestAct, defaultBatchSize, batchSize, _activityManager, getActivityHandlerByKey, getActivityByTypeAndParentId, query, _loop, _ret;

      return _regenerator2.default.wrap(function _callee9$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              // ***********************************************
              // INSTANCE STATE VARIABLES
              // variables that will be used for the life of the generator
              // ***********************************************

              _options$minActivitie = options.minActivities, minActivities = _options$minActivitie === undefined ? _activityThreadOrdering.defaultMinDisplayableActivities : _options$minActivitie, _options$queryType = options.queryType, queryType = _options$queryType === undefined ? _activities.INITIAL : _options$queryType;

              // must fetch initially before getting newer activities!

              if (queryType === _activities.NEWER) {
                queryType = _activities.INITIAL;
              }

              convoUrl = options.url, _options$search = options.search, search = _options$search === undefined ? {} : _options$search, includeChildren = options.includeChildren;

              // manage oldest, newest activities (ie bookends)

              _bookendManager = (0, _activityThreadOrdering.bookendManager)(), setBookends = _bookendManager.setBookends, getNewestAct = _bookendManager.getNewestAct, getOldestAct = _bookendManager.getOldestAct;

              // default batch should be equal to minActivities when fetching back in time, but halved when fetching newer due to subsequent child fetches filling up the minActivities count
              // reduces server RTs when fetching older activities

              defaultBatchSize = queryType === _activities.INITIAL || queryType === _activities.OLDER ? minActivities : Math.max(_activityThreadOrdering.minBatchSize, Math.ceil(minActivities / 2));
              batchSize = defaultBatchSize;

              // exposes activity states and handlers with simple getters

              _activityManager = (0, _activityThreadOrdering.activityManager)(), getActivityHandlerByKey = _activityManager.getActivityHandlerByKey, getActivityByTypeAndParentId = _activityManager.getActivityByTypeAndParentId;

              // set initial query

              query = (0, _activityThreadOrdering.getQuery)(queryType, { activityToSearch: search, batchSize: batchSize });

              /* eslint-disable no-await-in-loop */
              /* eslint-disable no-loop-func */

              _loop = /*#__PURE__*/_regenerator2.default.mark(function _loop() {
                var _rootActivityManager, getRootActivityHash, addNewRoot, _noMoreActivitiesMana, getNoMoreActs, checkAndSetNoMoreActs, checkAndSetNoOlderActs, checkAndSetNoNewerActs, getActivityHandlerByType, handleNewActivity, handleNewActivities, handleOlderQuery, handleNewerQuery, handleSearch, getQueryResponseHandler, incrementLoopCounter, _loop2, _ret2, orderedActivities, getRepliesByParentId, orderedRoots, nextOptions, _currentOldestPublishedDate, _currentNewestPublishedDate;

                return _regenerator2.default.wrap(function _loop$(_context10) {
                  while (1) {
                    switch (_context10.prev = _context10.next) {
                      case 0:
                        // ***********************************************
                        // EXECUTION STATE VARIABLES
                        // variables that will be used for each "batch" of activities asked for
                        // ***********************************************

                        // stores all "root" activities (activities that are, or could be, thread parents)
                        _rootActivityManager = (0, _activityThreadOrdering.rootActivityManager)(), getRootActivityHash = _rootActivityManager.getRootActivityHash, addNewRoot = _rootActivityManager.addNewRoot;

                        // used to determine if we should continue to fetch older activities
                        // must be set per iteration, as querying newer activities is still valid when all end of convo has been reached

                        _noMoreActivitiesMana = (0, _activityThreadOrdering.noMoreActivitiesManager)(), getNoMoreActs = _noMoreActivitiesMana.getNoMoreActs, checkAndSetNoMoreActs = _noMoreActivitiesMana.checkAndSetNoMoreActs, checkAndSetNoOlderActs = _noMoreActivitiesMana.checkAndSetNoOlderActs, checkAndSetNoNewerActs = _noMoreActivitiesMana.checkAndSetNoNewerActs;

                        getActivityHandlerByType = function getActivityHandlerByType(type) {
                          var _ACTIVITY_TYPES$ROOT$;

                          return (_ACTIVITY_TYPES$ROOT$ = {}, (0, _defineProperty3.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.ROOT, addNewRoot), (0, _defineProperty3.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.REPLY, getActivityHandlerByKey(_activities.ACTIVITY_TYPES.REPLY)), (0, _defineProperty3.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.EDIT, getActivityHandlerByKey(_activities.ACTIVITY_TYPES.EDIT)), (0, _defineProperty3.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.REACTION, getActivityHandlerByKey(_activities.ACTIVITY_TYPES.REACTION)), (0, _defineProperty3.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.REACTION_SELF, getActivityHandlerByKey(_activities.ACTIVITY_TYPES.REACTION_SELF)), (0, _defineProperty3.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.TOMBSTONE, addNewRoot), (0, _defineProperty3.default)(_ACTIVITY_TYPES$ROOT$, _activities.ACTIVITY_TYPES.CREATE, addNewRoot), _ACTIVITY_TYPES$ROOT$)[type];
                        };

                        handleNewActivity = function handleNewActivity(activity) {
                          var actType = (0, _activities.getActivityType)(activity);

                          // ignore deletes
                          if ((0, _activities.isDeleteActivity)(activity)) {
                            return;
                          }

                          var activityHandler = getActivityHandlerByType(actType);

                          activityHandler(activity);
                        };

                        handleNewActivities = function handleNewActivities(activities) {
                          activities.forEach(function (act) {
                            handleNewActivity(act);
                            checkAndSetNoOlderActs(act);
                          });
                        };

                        handleOlderQuery = function handleOlderQuery(activities) {
                          setBookends(activities, _activities.OLDER);
                          handleNewActivities(activities);
                        };

                        handleNewerQuery = function handleNewerQuery(activities) {
                          checkAndSetNoNewerActs(activities);
                          if (activities.length) {
                            setBookends(activities, _activities.NEWER);
                            handleNewActivities(activities);
                          }
                        };

                        handleSearch = function handleSearch(activities) {
                          setBookends(activities, _activities.MID);
                          handleNewActivities(activities);
                        };

                        getQueryResponseHandler = function getQueryResponseHandler(type) {
                          var _OLDER$NEWER$MID$INIT;

                          return (_OLDER$NEWER$MID$INIT = {}, (0, _defineProperty3.default)(_OLDER$NEWER$MID$INIT, _activities.OLDER, handleOlderQuery), (0, _defineProperty3.default)(_OLDER$NEWER$MID$INIT, _activities.NEWER, handleNewerQuery), (0, _defineProperty3.default)(_OLDER$NEWER$MID$INIT, _activities.MID, handleSearch), (0, _defineProperty3.default)(_OLDER$NEWER$MID$INIT, _activities.INITIAL, handleOlderQuery), _OLDER$NEWER$MID$INIT)[type];
                        };

                        // ***********************************************
                        // INNER LOOP
                        // responsible for fetching and building our maps of activities
                        // fetch until minActivities is reached, or no more acts to fetch, or we hit our max fetch count
                        // ***********************************************

                        incrementLoopCounter = (0, _activityThreadOrdering.getLoopCounterFailsafe)();
                        _loop2 = /*#__PURE__*/_regenerator2.default.mark(function _loop2() {
                          var allBatchActivitiesConfig, $allBatchActivitiesFetch, $fetchRequests, params, $parentsFetch, _ref17, _ref18, allBatchActivities, _ref18$, parents, handler, _parents$reply, replyIds, _parents$edit, editIds, _parents$reaction, reactionIds, $reactionFetches, $replyFetches, $editFetches, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, activity, actId, childFetchOptions, _ref19, _ref20, reactions, replies, edits, newReplyReactions, allReactions, rootActivityHash, visibleActivitiesCount, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, rootActivity, rootId, repliesByRootId, currentOldestPublishedDate, currentNewestPublishedDate;

                          return _regenerator2.default.wrap(function _loop2$(_context9) {
                            while (1) {
                              switch (_context9.prev = _context9.next) {
                                case 0:
                                  // count loops and throw if we detect infinite loop
                                  incrementLoopCounter();

                                  // configure fetch request. Use a smaller limit when fetching newer or mids to account for potential children fetches
                                  allBatchActivitiesConfig = (0, _extends3.default)({
                                    conversationUrl: convoUrl,
                                    limit: batchSize,
                                    includeChildren: includeChildren
                                  }, query);

                                  // request activities in batches

                                  $allBatchActivitiesFetch = _this24.listActivities(allBatchActivitiesConfig);

                                  // contain fetches in array to parallelize fetching as needed

                                  $fetchRequests = [$allBatchActivitiesFetch];

                                  // if query requires recursive fetches for children acts, add the additional fetch

                                  if (queryType === _activities.MID || queryType === _activities.NEWER) {
                                    params = { activityType: null };


                                    if (query.sinceDate) {
                                      params.sinceDate = query.sinceDate;
                                    }

                                    $parentsFetch = _this24.listParentActivityIds(convoUrl, params);


                                    $fetchRequests.push($parentsFetch);
                                  }

                                  // we dont always need to fetch for parents
                                  _context9.next = 7;
                                  return _asyncGenerator3.default.await(_promise2.default.all($fetchRequests));

                                case 7:
                                  _ref17 = _context9.sent;
                                  _ref18 = (0, _slicedToArray3.default)(_ref17, 2);
                                  allBatchActivities = _ref18[0];
                                  _ref18$ = _ref18[1];
                                  parents = _ref18$ === undefined ? {} : _ref18$;


                                  // use query type to decide how to handle response
                                  handler = getQueryResponseHandler(queryType);


                                  handler(allBatchActivities);

                                  /*
                                    next we must selectively fetch the children of each of the parents to ensure completeness
                                    do this by checking the hash for each of the above parent IDs
                                    fetch children when we have a parent whose ID is represented in the parent ID lists
                                  */
                                  _parents$reply = parents.reply, replyIds = _parents$reply === undefined ? [] : _parents$reply, _parents$edit = parents.edit, editIds = _parents$edit === undefined ? [] : _parents$edit, _parents$reaction = parents.reaction, reactionIds = _parents$reaction === undefined ? [] : _parents$reaction;

                                  // if no parent IDs returned, do nothing

                                  if (!(replyIds.length || editIds.length || reactionIds.length)) {
                                    _context9.next = 52;
                                    break;
                                  }

                                  $reactionFetches = [];
                                  $replyFetches = [];
                                  $editFetches = [];
                                  _iteratorNormalCompletion4 = true;
                                  _didIteratorError4 = false;
                                  _iteratorError4 = undefined;
                                  _context9.prev = 22;


                                  for (_iterator4 = (0, _getIterator3.default)(allBatchActivities); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                                    activity = _step4.value;
                                    actId = activity.id;
                                    childFetchOptions = {
                                      conversationUrl: convoUrl,
                                      activityParentId: actId
                                    };


                                    if (reactionIds.includes(actId)) {
                                      $reactionFetches.push(_this24.getReactionSummaryByParentId(convoUrl, actId, { activityType: 'reactionSummary', includeChildren: true }));
                                    }
                                    if (replyIds.includes(actId)) {
                                      childFetchOptions.query = { activityType: 'reply' };
                                      $replyFetches.push(_this24.listAllChildActivitiesByParentId(childFetchOptions));
                                    }
                                    if (editIds.includes(actId)) {
                                      childFetchOptions.query = { activityType: 'edit' };
                                      $editFetches.push(_this24.listAllChildActivitiesByParentId(childFetchOptions));
                                    }
                                  }

                                  // parallelize fetch for speeedz
                                  _context9.next = 30;
                                  break;

                                case 26:
                                  _context9.prev = 26;
                                  _context9.t0 = _context9['catch'](22);
                                  _didIteratorError4 = true;
                                  _iteratorError4 = _context9.t0;

                                case 30:
                                  _context9.prev = 30;
                                  _context9.prev = 31;

                                  if (!_iteratorNormalCompletion4 && _iterator4.return) {
                                    _iterator4.return();
                                  }

                                case 33:
                                  _context9.prev = 33;

                                  if (!_didIteratorError4) {
                                    _context9.next = 36;
                                    break;
                                  }

                                  throw _iteratorError4;

                                case 36:
                                  return _context9.finish(33);

                                case 37:
                                  return _context9.finish(30);

                                case 38:
                                  _context9.next = 40;
                                  return _asyncGenerator3.default.await(_promise2.default.all([_promise2.default.all($reactionFetches), _promise2.default.all($replyFetches), _promise2.default.all($editFetches)]));

                                case 40:
                                  _ref19 = _context9.sent;
                                  _ref20 = (0, _slicedToArray3.default)(_ref19, 3);
                                  reactions = _ref20[0];
                                  replies = _ref20[1];
                                  edits = _ref20[2];
                                  _context9.next = 47;
                                  return _asyncGenerator3.default.await(_promise2.default.all(replies.filter(function (reply) {
                                    return replyIds.includes(reply.id);
                                  }).map(function (reply) {
                                    return _this24.getReactionSummaryByParentId(convoUrl, reply.id, { activityType: 'reactionSummary', includeChildren: true });
                                  })));

                                case 47:
                                  newReplyReactions = _context9.sent;
                                  allReactions = [].concat((0, _toConsumableArray3.default)(reactions), (0, _toConsumableArray3.default)(newReplyReactions));

                                  // stick them into activity hashes

                                  replies.forEach(function (replyArr) {
                                    return handleNewActivities(replyArr);
                                  });
                                  edits.forEach(function (editArr) {
                                    return handleNewActivities(editArr);
                                  });
                                  allReactions.forEach(function (reactionArr) {
                                    return handleNewActivities(reactionArr);
                                  });

                                case 52:
                                  rootActivityHash = getRootActivityHash();
                                  visibleActivitiesCount = rootActivityHash.size;
                                  _iteratorNormalCompletion5 = true;
                                  _didIteratorError5 = false;
                                  _iteratorError5 = undefined;
                                  _context9.prev = 57;


                                  for (_iterator5 = (0, _getIterator3.default)(rootActivityHash.values()); !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                                    rootActivity = _step5.value;
                                    rootId = rootActivity.id;
                                    repliesByRootId = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.REPLY, rootId);


                                    if (repliesByRootId && repliesByRootId.size) {
                                      visibleActivitiesCount += repliesByRootId.size || 0;
                                    }
                                  }

                                  // stop fetching if we've reached desired count of visible activities
                                  _context9.next = 65;
                                  break;

                                case 61:
                                  _context9.prev = 61;
                                  _context9.t1 = _context9['catch'](57);
                                  _didIteratorError5 = true;
                                  _iteratorError5 = _context9.t1;

                                case 65:
                                  _context9.prev = 65;
                                  _context9.prev = 66;

                                  if (!_iteratorNormalCompletion5 && _iterator5.return) {
                                    _iterator5.return();
                                  }

                                case 68:
                                  _context9.prev = 68;

                                  if (!_didIteratorError5) {
                                    _context9.next = 71;
                                    break;
                                  }

                                  throw _iteratorError5;

                                case 71:
                                  return _context9.finish(68);

                                case 72:
                                  return _context9.finish(65);

                                case 73:
                                  if (!(visibleActivitiesCount >= minActivities)) {
                                    _context9.next = 75;
                                    break;
                                  }

                                  return _context9.abrupt('return', 'break');

                                case 75:

                                  checkAndSetNoMoreActs(queryType, visibleActivitiesCount, batchSize);

                                  // batchSize should be equal to minimum activities when fetching older activities
                                  // covers "best case" when we reach minActivities on the first fetch
                                  if (queryType === _activities.OLDER) {
                                    batchSize = minActivities;
                                  }

                                  // since a MID query can bump the batchSize, we need to reset it _after_ a potential MID query
                                  // reset batchSize in case of MID queries bumping it up
                                  if (queryType === _activities.NEWER) {
                                    batchSize = defaultBatchSize;
                                  }

                                  currentOldestPublishedDate = (0, _activities.getPublishedDate)(getOldestAct());
                                  currentNewestPublishedDate = (0, _activities.getPublishedDate)(getNewestAct());

                                  // we're still building our activity list - derive new query from prior query and start loop again

                                  if (queryType === _activities.INITIAL) {
                                    query = (0, _activityThreadOrdering.getQuery)(_activities.OLDER, { oldestPublishedDate: currentOldestPublishedDate, batchSize: batchSize });
                                  } else {
                                    query = (0, _activityThreadOrdering.getQuery)(queryType, {
                                      batchSize: batchSize,
                                      activityToSearch: search,
                                      oldestPublishedDate: currentOldestPublishedDate,
                                      newestPublishedDate: currentNewestPublishedDate
                                    });
                                  }

                                  // if we're still building out the midDate search, bump the search limit to include activities on both sides
                                  if (queryType === _activities.MID) {
                                    batchSize += _activityThreadOrdering.batchSizeIncrementCount;
                                  }

                                case 82:
                                case 'end':
                                  return _context9.stop();
                              }
                            }
                          }, _loop2, _this24, [[22, 26, 30, 38], [31,, 33, 37], [57, 61, 65, 73], [66,, 68, 72]]);
                        });

                      case 11:
                        if (getNoMoreActs()) {
                          _context10.next = 18;
                          break;
                        }

                        return _context10.delegateYield(_loop2(), 't0', 13);

                      case 13:
                        _ret2 = _context10.t0;

                        if (!(_ret2 === 'break')) {
                          _context10.next = 16;
                          break;
                        }

                        return _context10.abrupt('break', 18);

                      case 16:
                        _context10.next = 11;
                        break;

                      case 18:
                        orderedActivities = [];

                        getRepliesByParentId = function getRepliesByParentId(replyParentId) {
                          var replies = [];

                          var repliesByParentId = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.REPLY, replyParentId);

                          if (!repliesByParentId) {
                            return replies;
                          }

                          var sortedReplies = (0, _activities.sortActivitiesByPublishedDate)((0, _activityThreadOrdering.getActivityObjectsFromMap)(repliesByParentId));

                          sortedReplies.forEach(function (replyActivity) {
                            var replyId = replyActivity.id;
                            var edit = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.EDIT, replyId);
                            var reaction = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.REACTION, replyId);
                            var reactionSelf = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.REACTION_SELF, replyId);

                            var latestActivity = edit || replyActivity;
                            // hash of root activities (in case of plain reply) and the reply activity (in case of edit)
                            var allRelevantActivitiesArr = [].concat((0, _toConsumableArray3.default)((0, _activityThreadOrdering.getActivityObjectsFromMap)(getRootActivityHash())), (0, _toConsumableArray3.default)((0, _activityThreadOrdering.getActivityObjectsFromMap)(repliesByParentId)));
                            var allRelevantActivities = allRelevantActivitiesArr.reduce(function (hashMap, act) {
                              hashMap[act.id] = act;

                              return hashMap;
                            }, {});

                            var finalReply = _this24._createParsedServerActivity(latestActivity, allRelevantActivities);

                            var fullReply = {
                              id: replyId,
                              activity: finalReply,
                              reaction: reaction,
                              reactionSelf: reactionSelf
                            };

                            var sanitizedFullReply = (0, _activities.sanitizeActivity)(fullReply);

                            replies.push(sanitizedFullReply);
                          });

                          return replies;
                        };

                        orderedRoots = (0, _activities.sortActivitiesByPublishedDate)((0, _activityThreadOrdering.getActivityObjectsFromMap)(getRootActivityHash()));


                        orderedRoots.forEach(function (rootActivity) {
                          var rootId = rootActivity.id;
                          var replies = getRepliesByParentId(rootId);
                          var edit = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.EDIT, rootId);
                          var reaction = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.REACTION, rootId);
                          var reactionSelf = getActivityByTypeAndParentId(_activities.ACTIVITY_TYPES.REACTION_SELF, rootId);

                          var latestActivity = edit || rootActivity;
                          var finalActivity = _this24._createParsedServerActivity(latestActivity, (0, _defineProperty3.default)({}, rootId, rootActivity));

                          var fullRoot = {
                            id: rootId,
                            activity: finalActivity,
                            reaction: reaction,
                            reactionSelf: reactionSelf
                          };

                          var sanitizedFullRoot = (0, _activities.sanitizeActivity)(fullRoot);

                          orderedActivities.push(sanitizedFullRoot);
                          replies.forEach(function (reply) {
                            return orderedActivities.push(reply);
                          });
                        });

                        _context10.next = 24;
                        return orderedActivities;

                      case 24:
                        nextOptions = _context10.sent;

                        if (!nextOptions) {
                          _context10.next = 33;
                          break;
                        }

                        minActivities = nextOptions.minActivities || minActivities;

                        _currentOldestPublishedDate = (0, _activities.getPublishedDate)(getOldestAct());
                        _currentNewestPublishedDate = (0, _activities.getPublishedDate)(getNewestAct());


                        queryType = nextOptions.queryType;
                        query = (0, _activityThreadOrdering.getQuery)(queryType, {
                          activityToSearch: search,
                          oldestPublishedDate: _currentOldestPublishedDate,
                          newestPublishedDate: _currentNewestPublishedDate,
                          batchSize: batchSize
                        });
                        _context10.next = 34;
                        break;

                      case 33:
                        return _context10.abrupt('return', {
                          v: void 0
                        });

                      case 34:
                      case 'end':
                        return _context10.stop();
                    }
                  }
                }, _loop, _this24);
              });

            case 9:
              if (!true) {
                _context11.next = 16;
                break;
              }

              return _context11.delegateYield(_loop(), 't0', 11);

            case 11:
              _ret = _context11.t0;

              if (!((typeof _ret === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret)) === "object")) {
                _context11.next = 14;
                break;
              }

              return _context11.abrupt('return', _ret.v);

            case 14:
              _context11.next = 9;
              break;

            case 16:
            case 'end':
              return _context11.stop();
          }
        }
      }, _callee9, _this24);
    }))();
  },


  /**
   * @typedef {object} EditActivity
   * @property {object} editParent
   *
   * @typedef {object} ReplyActivity
   * @property {object} replyParent
   *
   * @typedef {object} EditedReplyActivity
   * @property {object} replyParent
   * @property {object} editParent
   *
   * @typedef {EditActivity | ReplyActivity | EditedReplyActivity} ParsedServerActivity
   */

  /**
    * hashmap of server activities, keyed by id
    * @typedef {object} ActivityHash
    * @property {Object}
    */

  /**
   * extends a given server object with fields that point to their parent activities from the hashmap passed in
   * @param {object} activity server activity
   * @param {ActivityHash} allActivitiesHash hashmap of all server activities caller would like to pass in
   * @returns {ParsedServerActivity} server activity extended with edit and reply parent fields
   */
  _createParsedServerActivity: function _createParsedServerActivity(activity) {
    var allActivitiesHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var isOrphan = (0, _activities.getIsActivityOrphaned)(activity, allActivitiesHash);

    if (isOrphan) {
      throw new Error('activity has a parent that cannot be found in allActivitiesHash! please handle this as necessary');
    }

    var activityType = (0, _activities.determineActivityType)(activity, allActivitiesHash);

    switch (activityType) {
      case _activities.ACTIVITY_TYPES.ROOT:
        {
          return (0, _activities.createRootActivity)(activity);
        }
      case _activities.ACTIVITY_TYPES.EDIT:
        {
          // `activities` must also have the original activity
          return (0, _activities.createEditActivity)(activity, allActivitiesHash);
        }
      case _activities.ACTIVITY_TYPES.REPLY:
        {
          return (0, _activities.createReplyActivity)(activity);
        }
      case _activities.ACTIVITY_TYPES.REPLY_EDIT:
        {
          // `activities` must also have the reply activity
          return (0, _activities.createReplyEditActivity)(activity, allActivitiesHash);
        }
      default:
        {
          return activity;
        }
    }
  },


  /**
   * @param {Object} options
   * @private
   * @returns {Promise<Array<Conversation>>}
   */
  _list: function () {
    var _ref21 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee10(options) {
      var _this25 = this;

      var res, list, limit, results, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, result, items;

      return _regenerator2.default.wrap(function _callee10$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              options.qs = (0, _assign2.default)({
                personRefresh: true,
                uuidEntryFormat: true,
                activitiesLimit: 0,
                participantsLimit: 0
              }, options.qs);

              _context12.next = 3;
              return this.request(options);

            case 3:
              res = _context12.sent;
              list = void 0;


              if (!res.body || !res.body.items || res.body.items.length === 0) {
                list = [];
              } else {
                list = res.body.items.slice(0);
                if ((0, _last3.default)(list).published < list[0].published) {
                  list.reverse();
                }
              }

              // The user has more data in another cluster.
              // Follow the 'additionalUrls' for that data.

              if (!res.body.additionalUrls) {
                _context12.next = 32;
                break;
              }

              limit = 0;

              // If the user asked for a specific amount of data,
              // don't fetch more than what was asked.
              // Here we figure out how much is left from the original request.
              // Divide that by the number of additional URLS.
              // This won't get us the exact limit but it will retrieve something
              // from every cluster listed.

              if (options.limit) {
                limit = Math.floor((options.limit.value - list.length) / res.body.additionalUrls.length);
              }

              // If the limit is 0 for some reason,
              // don't bother requesting from other clusters

              if (!(!options.limit || limit !== 0)) {
                _context12.next = 32;
                break;
              }

              _context12.next = 12;
              return _promise2.default.all(res.body.additionalUrls.map(function (host) {
                var url = host + '/' + options.resource;
                var newOptions = (0, _assign2.default)({}, options, { uri: url, url: url });

                if (options.limit) {
                  newOptions.qs[newOptions.limit.name] = limit;
                }

                return _this25.request(newOptions);
              }));

            case 12:
              results = _context12.sent;
              _iteratorNormalCompletion6 = true;
              _didIteratorError6 = false;
              _iteratorError6 = undefined;
              _context12.prev = 16;


              for (_iterator6 = (0, _getIterator3.default)(results); !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                result = _step6.value;

                if (result.body && result.body.items && result.body.items.length) {
                  items = result.body.items;


                  if ((0, _last3.default)(items).published < items[0].published) {
                    items.reverse();
                  }
                  list = list.concat(items);
                }
              }
              _context12.next = 24;
              break;

            case 20:
              _context12.prev = 20;
              _context12.t0 = _context12['catch'](16);
              _didIteratorError6 = true;
              _iteratorError6 = _context12.t0;

            case 24:
              _context12.prev = 24;
              _context12.prev = 25;

              if (!_iteratorNormalCompletion6 && _iterator6.return) {
                _iterator6.return();
              }

            case 27:
              _context12.prev = 27;

              if (!_didIteratorError6) {
                _context12.next = 30;
                break;
              }

              throw _iteratorError6;

            case 30:
              return _context12.finish(27);

            case 31:
              return _context12.finish(24);

            case 32:
              _context12.next = 34;
              return _promise2.default.all(list.map(function (item) {
                return _this25._recordUUIDs(item);
              }));

            case 34:
              return _context12.abrupt('return', list);

            case 35:
            case 'end':
              return _context12.stop();
          }
        }
      }, _callee10, this, [[16, 20, 24, 32], [25,, 27, 31]]);
    }));

    function _list(_x25) {
      return _ref21.apply(this, arguments);
    }

    return _list;
  }(),


  /**
   * @param {Object} params
   * @param {Object} options
   * @private
   * @returns {Promise<Conversation>}
   */
  _maybeCreateOneOnOneThenPost: function _maybeCreateOneOnOneThenPost(params, options) {
    var _this26 = this;

    return this.get((0, _defaults3.default)({
      // the use of uniq in Conversation#create guarantees participant[1] will
      // always be the other user
      user: params.participants[1]
    }), (0, _assign2.default)(options, { includeConvWithDeletedUserUUID: true, includeParticipants: true })).then(function (conversation) {
      if (params.comment || params.html) {
        return _this26.post(conversation, { content: params.html, displayName: params.comment }).then(function (activity) {
          conversation.activities.items.push(activity);

          return conversation;
        });
      }

      return conversation;
    }).catch(function (reason) {
      if (reason.statusCode !== 404) {
        return _promise2.default.reject(reason);
      }

      return _this26._createOneOnOne(params);
    });
  },


  /**
   * @param {Object} params
   * @private
   * @returns {Object}
   */
  _prepareConversationForCreation: function _prepareConversationForCreation(params) {
    var _this27 = this;

    var payload = {
      activities: {
        items: [this.expand('create')]
      },
      objectType: 'conversation',
      kmsMessage: {
        method: 'create',
        uri: '/resources',
        userIds: (0, _cloneDeep3.default)(params.participants),
        keyUris: []
      }
    };

    if (params.displayName) {
      payload.displayName = params.displayName;
    }

    params.participants.forEach(function (participant) {
      payload.activities.items.push(_this27.expand('add', {
        objectType: 'person',
        id: participant
      }));
    });

    if (params.comment) {
      payload.activities.items.push(this.expand('post', {
        objectType: 'comment',
        content: params.html,
        displayName: params.comment
      }));
    }

    return payload;
  },


  /**
   * @param {Object} conversation
   * @private
   * @returns {Promise}
   */
  _recordUUIDs: function _recordUUIDs(conversation) {
    var _this28 = this;

    if (!conversation.participants || !conversation.participants.items) {
      return _promise2.default.resolve(conversation);
    }

    return _promise2.default.all(conversation.participants.items.map(function (participant) {
      // ROOMs or LYRA_SPACEs do not have email addresses, so there's no point attempting to
      // record their UUIDs.
      if (participant.type === 'ROOM' || participant.type === 'LYRA_SPACE') {
        return _promise2.default.resolve();
      }

      return _this28.webex.internal.user.recordUUID(participant).catch(function (err) {
        return _this28.logger.warn('Could not record uuid', err);
      });
    }));
  },
  version: '1.92.7'
});

['favorite', 'hide', 'lock', 'mute', 'unfavorite', 'unhide', 'unlock', 'unmute'].forEach(function (verb) {
  Conversation.prototype[verb] = function submitSimpleActivity(conversation, activity) {
    var _this29 = this;

    var convoWithUrl = this.prepareConversation((0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) }));

    return this.prepare(activity, {
      verb: verb,
      object: convoWithUrl,
      target: convoWithUrl
    }).then(function (a) {
      return _this29.submit(a);
    });
  };
});

['assignModerator', 'unassignModerator'].forEach(function (verb) {
  Conversation.prototype[verb] = function submitModerationChangeActivity(conversation, moderator, activity) {
    var _this30 = this;

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return _promise2.default.all([convoWithUrl, moderator ? this.webex.internal.user.asUUID(moderator) : this.webex.internal.device.userId]).then(function (_ref22) {
      var _ref23 = (0, _slicedToArray3.default)(_ref22, 2),
          c = _ref23[0],
          userId = _ref23[1];

      return _this30.prepare(activity, {
        verb: verb,
        target: _this30.prepareConversation(c),
        object: {
          id: userId,
          objectType: 'person'
        }
      });
    }).then(function (a) {
      return _this30.submit(a);
    });
  };
});

/**
 * Sets/unsets space property for convo
 * @param {Object} conversation
 * @param {string} tag
 * @param {Activity} activity
 * @returns {Promise<Activity>}
 */
['setSpaceProperty', 'unsetSpaceProperty'].forEach(function (fnName) {
  var verb = fnName.startsWith('set') ? 'set' : 'unset';

  Conversation.prototype[fnName] = function submitSpacePropertyActivity(conversation, tag, activity) {
    var _this31 = this;

    if (!(0, _isString3.default)(tag)) {
      return _promise2.default.reject(new Error('`tag` must be a string'));
    }

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return this.prepare(activity, {
      verb: verb,
      target: this.prepareConversation(convoWithUrl),
      object: {
        tags: [tag],
        objectType: 'spaceProperty'
      }
    }).then(function (a) {
      return _this31.submit(a);
    });
  };
});

['tag', 'untag'].forEach(function (verb) {
  Conversation.prototype[verb] = function submitObjectActivity(conversation, object, activity) {
    var _this32 = this;

    if (!(0, _isObject3.default)(object)) {
      return _promise2.default.reject(new Error('`object` must be an object'));
    }

    var c = this.prepareConversation((0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) }));

    return this.prepare(activity, {
      verb: verb,
      target: c,
      object: (0, _assign2.default)(c, object)
    }).then(function (a) {
      return _this32.submit(a);
    });
  };
});

exports.default = Conversation;
//# sourceMappingURL=conversation.js.map
