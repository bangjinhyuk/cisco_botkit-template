{"version":3,"sources":["activity-thread-ordering.js"],"names":["defaultMinDisplayableActivities","minBatchSize","fetchLoopCountMax","batchSizeIncrementCount","setValue","destination","key","value","set","getValue","source","get","getActivityObjectsFromMap","hashMap","map","activity","activityManager","replyActivityHash","editActivityHash","reactionActivityHash","reactionSelfActivityHash","handleNewReply","replyAct","replyParentId","existingReplyHash","id","replyHash","handleNewEdit","editAct","isTombstone","verb","ACTIVITY_TYPES","TOMBSTONE","editParentId","existingEdit","reactionHelper","reactionAct","hash","reactionParentId","existingReaction","handleNewReaction","handleNewReactionSelf","reactionSelfAct","getActivityHandlerByKey","REACTION","REACTION_SELF","EDIT","REPLY","getActivityByTypeAndParentId","type","bookendManager","oldestAct","newestAct","getOldestAct","getNewestAct","setOldestAct","act","setNewestAct","setBookends","activities","oldestActsFirst","newestInBatch","oldestInBatch","noMoreActivitiesManager","noMoreActs","noOlderActs","noNewerActs","getNoMoreActs","checkAndSetNoOlderActs","CREATE","checkAndSetNoNewerActs","length","checkAndSetNoMoreActs","queryType","visibleActs","currentBatchSize","NEWER","OLDER","INITIAL","MID","rootActivityManager","rootActivityHash","addNewRoot","rootAct","getRootActivityHash","getLoopCounterFailsafe","fetchLoopCount","Error","getQuery","queryOptions","newestPublishedDate","oldestPublishedDate","batchSize","activityToSearch","sinceDate","lastActivityFirst","searchType","midDate","parent","published","limit","maxDate"],"mappings":"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","file":"activity-thread-ordering.js","sourcesContent":["import {last} from 'lodash';\n\nimport {\n  ACTIVITY_TYPES,\n  getParentId,\n  isNewer,\n  getActivityType,\n  sortActivitiesByPublishedDate,\n  NEWER,\n  OLDER,\n  INITIAL,\n  MID\n} from './activities';\n\nexport const defaultMinDisplayableActivities = 20;\nexport const minBatchSize = 10;\nexport const fetchLoopCountMax = 100;\nexport const batchSizeIncrementCount = 10;\n\n// use accessors for ease of refactoring underlying implementation\n/**\n * @param {Map} destination destination map object for data. Currently a Map, but could be refactored to use any type.\n * @param {string} key\n * @param {any} value\n * @returns {Map}\n */\nexport const setValue = (destination, key, value) => destination.set(key, value);\n/**\n * @param {Map} source source map object to access. Currently expects a Map, but could be refactored to use any type\n * @param {string} key\n * @returns {Map}\n */\nexport const getValue = (source, key) => source.get(key);\n\nexport const getActivityObjectsFromMap = (hashMap) => Array.from(hashMap).map(([, activity]) => activity);\n/**\n * creates maps for various activity types and defines handlers for working with stored activities\n * utilizes revealing module pattern to close over state and only expose certain necessary functions for altering state\n * @function\n * @returns {object}\n * getActivityHandlerByKey(activityType) - accepts a key to map to a defined activity handler\n * getActivityByTypeAndParentId(activityType, parentId) accepts a key and a parent ID to return an activity of that type whose parent is the parentId\n */\nexport const activityManager = () => {\n  const replyActivityHash = new Map();\n  const editActivityHash = new Map();\n  const reactionActivityHash = new Map();\n  const reactionSelfActivityHash = new Map();\n\n  const handleNewReply = (replyAct) => {\n    const replyParentId = getParentId(replyAct);\n    const existingReplyHash = getValue(replyActivityHash, replyParentId);\n\n    if (existingReplyHash) {\n      setValue(existingReplyHash, replyAct.id, replyAct);\n    }\n    else {\n      const replyHash = new Map();\n\n      setValue(replyHash, replyAct.id, replyAct);\n      setValue(replyActivityHash, replyParentId, replyHash);\n    }\n  };\n\n  const handleNewEdit = (editAct) => {\n    const isTombstone = editAct.verb === ACTIVITY_TYPES.TOMBSTONE;\n\n    // we can ignore tombstone edits in favor of the newer one\n    if (isTombstone) {\n      return;\n    }\n\n    const editParentId = getParentId(editAct);\n    const existingEdit = getValue(editActivityHash, editParentId);\n\n    // edited activity must be newer than what we already have\n    if (!existingEdit || isNewer(editAct, existingEdit)) {\n      setValue(editActivityHash, editParentId, editAct);\n    }\n  };\n\n  // logic is identical between reactions and reaction selfs, so handler simply passes the activity and the correct hash\n  const reactionHelper = (reactionAct, hash) => {\n    const reactionParentId = getParentId(reactionAct);\n    const existingReaction = getValue(hash, reactionParentId);\n\n    // reaction activity must be newer than what we already have\n    if (!existingReaction || isNewer(reactionAct, existingReaction)) {\n      setValue(hash, reactionParentId, reactionAct);\n    }\n  };\n\n  const handleNewReaction = (reactionAct) => {\n    reactionHelper(reactionAct, reactionActivityHash);\n  };\n\n  const handleNewReactionSelf = (reactionSelfAct) => {\n    reactionHelper(reactionSelfAct, reactionSelfActivityHash);\n  };\n\n  const getActivityHandlerByKey = (key) => ({\n    [ACTIVITY_TYPES.REACTION]: handleNewReaction,\n    [ACTIVITY_TYPES.REACTION_SELF]: handleNewReactionSelf,\n    [ACTIVITY_TYPES.EDIT]: handleNewEdit,\n    [ACTIVITY_TYPES.REPLY]: handleNewReply\n  }[key]);\n\n  const getActivityByTypeAndParentId = (type, id) => ({\n    [ACTIVITY_TYPES.EDIT]: getValue(editActivityHash, id),\n    [ACTIVITY_TYPES.REPLY]: getValue(replyActivityHash, id),\n    [ACTIVITY_TYPES.REACTION]: getValue(reactionActivityHash, id),\n    [ACTIVITY_TYPES.REACTION_SELF]: getValue(reactionSelfActivityHash, id)\n  }[type]);\n\n  return {\n    getActivityHandlerByKey,\n    getActivityByTypeAndParentId\n  };\n};\n\n/**\n * encapsulates state and logic for managing oldest and newest activities\n * @returns {object} setters and getters for activity state management\n */\nexport const bookendManager = () => {\n  // keep track of generator state, like what our current oldest & newest activities are\n  let oldestAct;\n  let newestAct;\n\n  const getOldestAct = () => oldestAct;\n  const getNewestAct = () => newestAct;\n\n  const setOldestAct = (act) => {\n    if (!oldestAct) {\n      oldestAct = act;\n    }\n    else if (isNewer(oldestAct, act)) {\n      oldestAct = act;\n    }\n  };\n\n  const setNewestAct = (act) => {\n    if (!newestAct) {\n      newestAct = act;\n    }\n    else if (isNewer(act, newestAct)) {\n      newestAct = act;\n    }\n  };\n\n  const setBookends = (activities) => {\n    const oldestActsFirst = sortActivitiesByPublishedDate(activities);\n\n    const newestInBatch = last(oldestActsFirst);\n    const oldestInBatch = oldestActsFirst[0];\n\n    setOldestAct(oldestInBatch);\n    setNewestAct(newestInBatch);\n  };\n\n  return {\n    setBookends,\n    getNewestAct,\n    getOldestAct\n  };\n};\n\n/**\n * encapsulates state and logic for when there are no more fetchable activities from convo\n * @returns {object} setters and getters for no more activities logic\n */\nexport const noMoreActivitiesManager = () => {\n  // used to determine if we should continue to fetch older activities\n  // must be set per iteration, as querying newer activities is still valid when all end of convo has been reached\n  let noMoreActs = false;\n  let noOlderActs = false;\n  let noNewerActs = false;\n\n  const getNoMoreActs = () => noMoreActs;\n\n  const checkAndSetNoOlderActs = (act) => {\n    if (!noOlderActs && getActivityType(act) === ACTIVITY_TYPES.CREATE) {\n      noOlderActs = true;\n    }\n  };\n\n  const checkAndSetNoNewerActs = (activities) => {\n    if (!activities || !activities.length) {\n      noNewerActs = true;\n    }\n  };\n\n  const checkAndSetNoMoreActs = (queryType, visibleActs, currentBatchSize) => {\n    if (\n      (queryType === NEWER && noNewerActs) ||\n      ((queryType === OLDER || queryType === INITIAL) && noOlderActs) ||\n      (queryType === MID && visibleActs < currentBatchSize && noOlderActs)\n    ) {\n      noMoreActs = true;\n    }\n  };\n\n  return {\n    getNoMoreActs,\n    checkAndSetNoMoreActs,\n    checkAndSetNoNewerActs,\n    checkAndSetNoOlderActs\n  };\n};\n\n/**\n * encapsulates state and logic for managing root activities\n * @returns {object} setters and getters for activity state management\n */\nexport const rootActivityManager = () => {\n  const rootActivityHash = new Map();\n\n  const addNewRoot = (rootAct) => {\n    setValue(rootActivityHash, rootAct.id, rootAct);\n  };\n\n  const getRootActivityHash = () => rootActivityHash;\n\n  return {\n    addNewRoot,\n    getRootActivityHash\n  };\n};\n\nexport const getLoopCounterFailsafe = () => {\n  let fetchLoopCount = 0;\n\n  return () => {\n    fetchLoopCount += 1;\n    if (fetchLoopCount > fetchLoopCountMax) {\n      throw new Error('max fetches reached');\n    }\n  };\n};\n\n/**\n * creates activity query object\n * @param {string} type type of query to create\n * @param {object} queryOptions options to define query\n * @param {string} [queryOptions.newestPublishedDate] the date of the newest fetched activity\n * @param {string} [queryOptions.oldestPublishedDate] the date of the oldest fetched activity\n * @param {number} [queryOptions.batchSize] the number of activities to query\n * @param {object} [queryOptions.activityToSearch] a server activity to use to build middate query\n * @returns {object}\n */\nexport const getQuery = (type, queryOptions) => {\n  const {\n    newestPublishedDate, oldestPublishedDate, batchSize, activityToSearch = {}\n  } = queryOptions;\n\n  switch (type) {\n    case NEWER: {\n      const sinceDate = newestPublishedDate + 1;\n      const lastActivityFirst = false;\n\n      return {sinceDate, lastActivityFirst};\n    }\n    case MID: {\n      const searchType = getActivityType(activityToSearch);\n      let midDate;\n\n      if (searchType === ACTIVITY_TYPES.REPLY || searchType === ACTIVITY_TYPES.EDIT) {\n        midDate = activityToSearch.parent.published;\n      }\n      else {\n        midDate = activityToSearch.published;\n      }\n\n      return {midDate, limit: batchSize};\n    }\n    case OLDER: {\n      const maxDate = oldestPublishedDate - 1;\n\n      return {maxDate};\n    }\n    case INITIAL:\n    default: {\n      return {};\n    }\n  }\n};\n"]}