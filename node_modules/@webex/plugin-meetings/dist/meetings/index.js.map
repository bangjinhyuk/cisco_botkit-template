{"version":3,"sources":["index.js"],"names":["Meetings","args","namespace","MEETINGS","meetingInfo","MeetingInfo","parent","webex","request","Request","loggerRequest","LoggerRequest","meetingCollection","MeetingCollection","personalMeetingRoom","PersonalMeetingRoom","reachability","registered","onReady","MeetingsUtil","triggerH264Codec","Metrics","initialSetup","data","meeting","getByKey","LOCUS_URL","locusUrl","CORRELATION_ID","checkForCorrelationId","internal","device","url","locus","SIP_URI","self","callbackInfo","callbackAddress","CONVERSATION_URL","conversationUrl","replaces","length","some","replacedLocus","fullState","state","LOCUS","STATE","INACTIVE","LoggerProxy","logger","warn","_LEFT_","removed","create","_LOCUS_ID_","then","newMeeting","eventType","LOCUSEVENT","DIFFERENCE","locusInfo","catch","e","console","log","finally","getMeetingByType","_ID_","id","postEvent","event","NOTIFICATION_RECEIVED","trigger","MERCURY_EVENT","REMOTE_STARTED","Trigger","file","function","EVENT_TRIGGERS","MEETING_ADDED","type","_MEETING_","_JOIN_","_INCOMING_","parse","envelope","MESSAGE_ROAP","handleLocusEvent","MEETINGS_NETWORK_DISCONNECTED","mercury","on","LOCUS_MERCURY","handleLocusMercury","ROAP","ROAP_MERCURY","handleRoapMercury","ONLINE","syncMeetings","OFFLINE","handleMercuryOffline","off","once","READY","StaticConfig","set","config","LoggerConfig","logging","MEETINGS_READY","canAuthorize","error","reject","Error","info","resolve","register","connect","listenForEvents","MEETINGS_REGISTERED","message","stopListeningForEvents","disconnect","unregister","MEETINGS_UNREGISTERED","options","uploadLogs","Reachability","setReachability","getReachability","gatherReachability","reason","autoUploadLogs","callStart","lastActive","undefined","correlationId","feedbackId","locusId","uploadResult","MEETING_LOG_UPLOAD_SUCCESS","meetingId","details","uploadError","MEETING_LOG_UPLOAD_FAILURE","delete","MEETING_REMOVED","destination","fetchInfoOptions","targetDest","wasHydraPerson","_CONVERSATION_URL_","createMeeting","createdMeeting","EVENTS","DESTROY_MEETING","payload","destroy","Meeting","userId","deviceUrl","orgId","roapSeq","fetchMeetingInfo","extractDestination","parseMeetingInfo","body","debug","sipUri","setSipUri","meetingAddedType","getMeetingAddedType","value","getAll","getActiveMeetings","locusArray","activeLocusUrl","loci","forEach","push","includes","MEETING_REMOVED_REASON","NO_MEETINGS_TO_SYNC","scheduled","get","StatsAnalyzer","StatsCalculator","WebexPlugin"],"mappings":"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","file":"index.js","sourcesContent":["/*!\n  * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n*/\n\nimport '@webex/internal-plugin-mercury';\nimport {forEach} from 'lodash';\nimport {WebexPlugin} from '@webex/webex-core';\n\nimport Metrics from '../metrics';\nimport {trigger, eventType} from '../metrics/config';\nimport LoggerConfig from '../common/logs/logger-config';\nimport StaticConfig from '../common/config';\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport LoggerRequest from '../common/logs/request';\nimport Trigger from '../common/events/trigger-proxy';\nimport {\n  MEETINGS,\n  EVENTS,\n  EVENT_TRIGGERS,\n  READY,\n  LOCUSEVENT,\n  LOCUS_URL,\n  ROAP,\n  ONLINE,\n  OFFLINE,\n  _MEETING_,\n  _JOIN_,\n  _LOCUS_ID_,\n  _INCOMING_,\n  LOCUS,\n  CORRELATION_ID,\n  SIP_URI,\n  _LEFT_,\n  _ID_,\n  MEETING_REMOVED_REASON,\n  _CONVERSATION_URL_,\n  CONVERSATION_URL\n} from '../constants';\nimport MeetingInfo from '../meeting-info';\nimport Meeting from '../meeting';\nimport PersonalMeetingRoom from '../personal-meeting-room';\nimport Reachability from '../reachability';\nimport Request from '../meetings/request';\nimport StatsAnalyzer from '../analyzer/analyzer';\nimport StatsCalculator from '../analyzer/calculator';\n\nimport MeetingCollection from './collection';\nimport MeetingsUtil from './util';\n\n\n/**\n   * Meetings Ready Event\n   * Emitted when the meetings instance on webex is ready\n   * @event meetings:ready\n   * @instance\n   * @memberof Meetings\n   */\n\n/**\n   * Meetings Network Disconnected Event\n   * Emitted when the meetings instance is disconnected from\n   * the internal mercury server\n   * @event network:disconnected\n   * @instance\n   * @memberof Meetings\n   */\n\n/**\n * Meetings Registered Event\n * Emitted when the meetings instance has been registered and listening\n * @event meetings:registered\n * @instance\n * @memberof Meetings\n */\n\n/**\n    * Meeting Removed Event\n    * Emitted when a meeting was removed from the cache of meetings\n    * @event meeting:removed\n    * @instance\n    * @type {Object}\n    * @property {String} meetingId the removed meeting\n    * @property {Object} response the server response\n    * @property {String} type what type of meeting it was\n    * @memberof Meetings\n    */\n\n/**\n    * Meeting Added Event\n    * Emitted when a meeting was added to the cache of meetings\n    * @event meeting:added\n    * @instance\n    * @type {Object}\n    * @property {String} meetingId the added meeting\n    * @property {String} type what type of meeting it was\n    * @memberof Meetings\n    */\n\n/**\n   * Maintain a cache of meetings and sync with services.\n   * @class\n   */\nexport default class Meetings extends WebexPlugin {\n    namespace = MEETINGS;\n\n    /**\n     * Initializes the Meetings Plugin\n     * @constructor\n     * @public\n     * @memberof Meetings\n     */\n    constructor(...args) {\n      super(...args);\n      /**\n       * The MeetingInfo object to interact with server\n       * @instance\n       * @type {Object}\n       * @private\n       * @memberof Meetings\n       */\n      this.meetingInfo = new MeetingInfo({}, {parent: this.webex});\n      /**\n       * The Meetings request to interact with server\n       * @instance\n       * @type {Object}\n       * @private\n       * @memberof Meetings\n       */\n      this.request = new Request({}, {parent: this.webex});\n      /**\n       * Log upload request helper\n       * @instance\n       * @type {Object}\n       * @private\n       * @memberof Meetings\n       */\n      this.loggerRequest = new LoggerRequest({webex: this.webex});\n      this.meetingCollection = new MeetingCollection();\n      /**\n       * The PersonalMeetingRoom object to interact with server\n       * @instance\n       * @type {Object}\n       * @public\n       * @memberof Meetings\n       */\n      this.personalMeetingRoom = new PersonalMeetingRoom({}, {parent: this.webex});\n      /**\n       * The Reachability object to interact with server, starts as null until {@link Meeting#setReachability} is called\n       * starts as null\n       * @instance\n       * @type {Object}\n       * @private\n       * @memberof Meetings\n       */\n      this.reachability = null;\n\n      /**\n       * If the meetings plugin has been registered and listening via {@link Meetings#register}\n       * @instance\n       * @type {Boolean}\n       * @public\n       * @memberof Meetings\n       */\n      this.registered = false;\n\n      this.onReady();\n\n      MeetingsUtil.triggerH264Codec();\n      Metrics.initialSetup(this.meetingCollection, this.webex);\n    }\n\n    /**\n     * handle locus events and takes meeting actions with them as they come in\n     * @param {Object} data a locus event\n     * @param {String} data.locusUrl\n     * @param {Object} data.locus\n     * @param {String} data.eventType\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n    handleLocusEvent(data) {\n      let meeting = null;\n\n      // getting meeting by correlationId. This will happen for the new event\n      // Either the locus\n      // TODO : Add check for the callBack Address\n      meeting = this.meetingCollection.getByKey(LOCUS_URL, data.locusUrl) ||\n      this.meetingCollection.getByKey(CORRELATION_ID, MeetingsUtil.checkForCorrelationId(this.webex.internal.device.url, data.locus)) ||\n      this.meetingCollection.getByKey(SIP_URI, data.locus.self && data.locus.self.callbackInfo && data.locus.self.callbackInfo.callbackAddress) ||\n      this.meetingCollection.getByKey(CONVERSATION_URL, data.locus.conversationUrl);\n\n      // Special case when locus has got replaced, This only happend once if a replace locus exists\n      // https://sqbu-github.cisco.com/WebExSquared/locus/wiki/Locus-changing-mid-call\n\n      if (data.locus && data.locus.replaces && data.locus.replaces.length > 0) {\n        // Findes the first occurence of the meeting in the collection with same locus url\n        meeting = data.locus.replaces.some((replacedLocus) => this.meetingCollection.getByKey(LOCUS_URL, replacedLocus.locusUrl));\n      }\n\n      if (!meeting) {\n        // TODO: create meeting when we get a meeting object\n        // const checkForEnded = (locus) => {\n        // TODO: you already ended the meeting but you got an event later\n        // Mainly for 1:1 Callsor meeting\n        // Happens mainly after refresh\n\n        // 1:1 Meeting\n        // 1)  You ended a call before but you got a mercury event\n        // Make sure end the call and cleanup the meeting only if the mercury\n        // event says so\n        // 2) Maintain lastSync time in the meetings object which helps to compare\n        // If the meeting came befor or after the sync . ANy meeting start time before the sync time is invalid\n\n        // For space Meeting\n        // Check the locus object and see who has joined\n\n        // };\n        // rather then locus object change to locus url\n\n        if (data.locus && data.locus.fullState && data.locus.fullState.state === LOCUS.STATE.INACTIVE) {\n          // just ignore the event as its already ended and not active\n          LoggerProxy.logger.warn('Meetings:index#handleLocusEvent --> Locus event received for meeting, after it was ended.');\n\n          return;\n        }\n\n\n        // When its wireless share or guest and user leaves the meeting we dont have to keep the meeting object\n        // Any future events will be neglected\n\n        if (data.locus && data.locus.self && (data.locus.self.state === _LEFT_ && data.locus.self.removed === true)) {\n          // just ignore the event as its already ended and not active\n          LoggerProxy.logger.warn('Meetings:index#handleLocusEvent --> Locus event received for meeting, after it was ended.');\n\n          return;\n        }\n\n        this.create(data.locus, _LOCUS_ID_).then((newMeeting) => {\n          meeting = newMeeting;\n\n          if (data.eventType === LOCUSEVENT.DIFFERENCE) {\n            // its a delta object and we have a new meeting\n            meeting.locusInfo.initialSetup(data.locus, meeting);\n          }\n          else {\n            // Its a new meeting and have a fresh locus object\n            meeting.locusInfo.initialSetup(data.locus);\n          }\n        }).catch((e) => {\n          console.log(e);\n        })\n          .finally(() => {\n            // There will be cases where locus event comes in gets created and deleted because its a 1:1 and meeting gets deleted\n            // because the other user left so before sending 'added' event make sure it exists in the collection\n\n            if (this.getMeetingByType(_ID_, meeting.id)) {\n            // Had to put `meeting:added here as the parsing of the locus object is done here\n              Metrics.postEvent({event: eventType.NOTIFICATION_RECEIVED, meeting, data: {trigger: trigger.MERCURY_EVENT}});\n\n              Metrics.postEvent({event: eventType.REMOTE_STARTED, meeting, data: {trigger: trigger.MERCURY_EVENT}});\n              Trigger.trigger(\n                this,\n                {\n                  file: 'meetings',\n                  function: 'handleLocusEvent'\n                },\n                EVENT_TRIGGERS.MEETING_ADDED,\n                {\n                  meeting,\n                  type: meeting.type === _MEETING_ ? _JOIN_ : _INCOMING_\n                }\n              );\n            }\n            else {\n              // Meeting got added but was not found in the collection. It might have got destroyed\n              LoggerProxy.logger.warn('Meetings:index#handleLocusEvent --> Created and destroyed meeting object before sending an event');\n            }\n          });\n      }\n      else {\n        Metrics.postEvent({event: eventType.NOTIFICATION_RECEIVED, meeting, data: {trigger: trigger.MERCURY_EVENT}});\n        meeting.locusInfo.parse(meeting, data);\n      }\n    }\n\n    /**\n     * handles locus events through mercury that are not roap\n     * @param {Object} envelope\n     * @param {Object} envelope.data\n     * @param {String} envelope.data.eventType\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n    handleLocusMercury(envelope) {\n      const {data} = envelope;\n      const {eventType} = data;\n\n      if (eventType && eventType !== LOCUSEVENT.MESSAGE_ROAP) {\n        this.handleLocusEvent(data);\n      }\n    }\n\n\n    /**\n     * handles mecury offline event\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n    handleMercuryOffline() {\n      Trigger.trigger(\n        this,\n        {\n          file: 'meetings/index',\n          function: 'handleMercuryOffline'\n        },\n        EVENT_TRIGGERS.MEETINGS_NETWORK_DISCONNECTED,\n      );\n    }\n\n\n    /**\n     * registers for locus and roap mercury events\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n    listenForEvents() {\n      this.webex.internal.mercury.on(LOCUSEVENT.LOCUS_MERCURY, (envelope) => {\n        this.handleLocusMercury(envelope);\n      });\n      this.webex.internal.mercury.on(ROAP.ROAP_MERCURY, (envelope) => {\n        MeetingsUtil.handleRoapMercury(envelope, this.meetingCollection);\n      });\n\n      this.webex.internal.mercury.on(ONLINE, () => {\n        this.syncMeetings();\n      });\n\n      this.webex.internal.mercury.on(OFFLINE, () => {\n        this.handleMercuryOffline();\n      });\n    }\n\n    /**\n     * stops listening for locus and roap mercury events\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n    stopListeningForEvents() {\n      this.webex.internal.mercury.off(LOCUSEVENT.LOCUS_MERCURY);\n      this.webex.internal.mercury.off(ROAP.ROAP_MERCURY);\n      this.webex.internal.mercury.off(ONLINE);\n    }\n\n    /**\n     * @returns {undefined}\n     * @private\n     * @memberof Meetings\n     */\n    onReady() {\n      this.webex.once(READY, () => {\n        StaticConfig.set(this.config);\n        LoggerConfig.set(this.config.logging);\n        LoggerProxy.set(this.webex.logger);\n        Trigger.trigger(\n          this,\n          {\n            file: 'meetings',\n            function: 'onReady'\n          },\n          EVENT_TRIGGERS.MEETINGS_READY\n        );\n      });\n    }\n\n    /**\n     * Explicitly sets up the meetings plugin by registering\n     * the device, connecting to mercury, and listening for locus events.\n     *\n     * @returns {Promise}\n     * @public\n     * @memberof Meetings\n     */\n    register() {\n      if (!this.webex.canAuthorize) {\n        LoggerProxy.logger.error('Meetings:index#register --> ERROR, Unable to register, SDK cannot authorize');\n\n        return Promise.reject(new Error('SDK cannot authorize'));\n      }\n\n      if (this.registered) {\n        LoggerProxy.logger.info('Meetings:index#register --> INFO, Meetings plugin already registered');\n\n        return Promise.resolve();\n      }\n\n      return this.webex.internal.device.register()\n        .then(() => this.webex.internal.mercury.connect())\n        .then(() => {\n          this.listenForEvents();\n          Trigger.trigger(\n            this,\n            {\n              file: 'meetings',\n              function: 'register'\n            },\n            EVENT_TRIGGERS.MEETINGS_REGISTERED\n          );\n          this.registered = true;\n        })\n        .catch((error) => {\n          LoggerProxy.logger.error(`Meetings:index#register --> ERROR, Unable to register, ${error.message}`);\n\n          return Promise.reject(error);\n        });\n    }\n\n    /**\n     * Explicitly tears down the meetings plugin by deregistering\n     * the device, disconnecting from mercury, and stops listening to locus events\n     *\n     * @returns {Promise}\n     * @public\n     * @memberof Meetings\n     */\n    unregister() {\n      if (!this.registered) {\n        LoggerProxy.logger.info('Meetings:index#unregister --> INFO, Meetings plugin already unregistered');\n\n        return Promise.resolve();\n      }\n\n      this.stopListeningForEvents();\n\n      return this.webex.internal.mercury.disconnect()\n        .then(() => this.webex.internal.device.unregister())\n        .then(() => {\n          Trigger.trigger(\n            this,\n            {\n              file: 'meetings',\n              function: 'unregister'\n            },\n            EVENT_TRIGGERS.MEETINGS_UNREGISTERED\n          );\n          this.registered = false;\n        });\n    }\n\n    /**\n     * Uploads logs to the webex services for tracking\n     * @param {Object} [options={}]\n     * @param {String} [options.feedbackId] ID used for tracking\n     * @param {String} [options.locusId]\n     * @param {Stirng} [options.correlationId]\n     * @returns {String} feedback ID logs were submitted under\n     */\n    uploadLogs(options = {}) {\n      return this.loggerRequest.uploadLogs(options);\n    }\n\n    /**\n     * initializes the reachability instance for Meetings\n     * @returns {undefined}\n     * @public\n     * @memberof Meetings\n     */\n    setReachability() {\n      this.reachability = new Reachability({}, {parent: this.webex});\n    }\n\n    /**\n     * gets the reachability instance for Meetings\n     * @returns {Reachability}\n     * @public\n     * @memberof Meetings\n     */\n    getReachability() {\n      return this.reachability;\n    }\n\n    /**\n     * initializes and starts gathering reachability for Meetings\n     * @returns {undefined}\n     * @public\n     * @memberof Meetings\n     */\n    startReachability() {\n      if (!this.reachability) {\n        this.setReachability();\n      }\n      this.getReachability().gatherReachability();\n    }\n\n    /**\n     * gets the personal meeting room instance, for saved PMR values for this user\n     * @returns {PersonalMeetingRoom}\n     * @public\n     * @memberof Meetings\n     */\n    getPersonalMeetingRoom() {\n      return this.personalMeetingRoom;\n    }\n\n    /**\n     * @param {Meeting} meeting\n     * @param {Object} reason\n     * @param {String} type\n     * @returns {Undefined}\n     * @private\n     * @memberof Meetings\n     */\n    destroy(meeting, reason) {\n      if (this.config.autoUploadLogs) {\n        LoggerProxy.logger.info('Meetings:index#destroy --> Meeting destroyed, uploading logs');\n        const callStart = meeting.locusInfo && meeting.locusInfo.fullState ? meeting.locusInfo.fullState.lastActive : undefined;\n\n        this.uploadLogs({\n          callStart,\n          correlationId: meeting.correlationId,\n          feedbackId: meeting.correlationId,\n          locusId: meeting.locusId\n        })\n          .then((uploadResult) => {\n            LoggerProxy.logger.info('Meetings:index#destroy --> Upload logs for meeting completed.', uploadResult);\n            Trigger.trigger(\n              this,\n              {\n                file: 'meetings',\n                function: 'destroy'\n              },\n              EVENT_TRIGGERS.MEETING_LOG_UPLOAD_SUCCESS,\n              {\n                meetingId: meeting.id,\n                details: uploadResult\n              }\n            );\n          })\n          .catch((uploadError) => {\n            LoggerProxy.logger.error('Meetings:index#destroy --> Unable to upload logs for meeting', uploadError);\n            Trigger.trigger(\n              this,\n              {\n                file: 'meetings',\n                function: 'destroy'\n              },\n              EVENT_TRIGGERS.MEETING_LOG_UPLOAD_FAILURE,\n              {\n                meetingId: meeting.id,\n                reason: uploadError\n              }\n            );\n          });\n      }\n\n      this.meetingCollection.delete(meeting.id);\n      Trigger.trigger(\n        this,\n        {\n          file: 'meetings',\n          function: 'destroy'\n        },\n        EVENT_TRIGGERS.MEETING_REMOVED,\n        {\n          meetingId: meeting.id,\n          reason\n        }\n      );\n    }\n\n    /**\n     * Create a meeting.\n     * @param {string} destination - sipURL, spaceId, phonenumber, meeting link, or locus object}\n     * @param {string} [type] - the optional specified type, such as locusId\n     * @returns {Promise<Meeting>} A new Meeting.\n     * @public\n     * @memberof Meetings\n     */\n    create(destination, type = null) {\n      // TODO: type should be from a dictionary\n\n      // Validate meeting information based on the provided destination and\n      // type. This must be performed prior to determining if the meeting is\n      // found in the collection, as we mutate the destination for hydra person\n      // id values.\n      return this.meetingInfo.fetchInfoOptions(destination, type)\n        // Catch a failure to fetch info options.\n        .catch((error) => {\n          LoggerProxy.logger.info(`Meetings:index#create --> INFO, unable to determine info options: ${error.message}`);\n        })\n        .then((options = {}) => {\n          // Normalize the destination.\n          const targetDest = options.wasHydraPerson ? options.destination : destination;\n\n\n          // check for the conversation URL then sip Url\n          let meeting = null;\n\n          if (type === _CONVERSATION_URL_ || options.type === _CONVERSATION_URL_) {\n            meeting = this.meetingCollection.getByKey(CONVERSATION_URL, targetDest);\n          }\n\n          // Attempt to collect the meeting if it exists.\n          if (!meeting) {\n            meeting = this.meetingCollection.getByKey(SIP_URI, targetDest);\n          }\n\n\n          // Validate if a meeting was found.\n          if (!meeting) {\n            // Create a meeting based on the normalized destination and type.\n            return this.createMeeting(targetDest, type)\n              .then((createdMeeting) => {\n                // If the meeting was successfully created.\n                if (createdMeeting && createdMeeting.on) {\n                  // Create a destruction event for the meeting.\n                  createdMeeting.on(EVENTS.DESTROY_MEETING, (payload) => {\n                    this.destroy(createdMeeting, payload.reason);\n                  });\n                }\n                else {\n                  LoggerProxy.logger.error(`Meetings:index#create --> ERROR, meeting does not have on method, will not be destroyed, meeting cleanup impossible for meeting: ${meeting}`);\n                }\n\n                // Return the newly created meeting.\n                return Promise.resolve(createdMeeting);\n              });\n          }\n\n          // Return the existing meeting.\n          return Promise.resolve(meeting);\n        });\n    }\n\n    /**\n     * @param {String} destination see create()\n     * @param {String} type see create()\n     * @returns {Promise} a new meeting instance complete with meeting info and destination\n     * @private\n     * @memberof Meetings\n     */\n    async createMeeting(destination, type = null) {\n      const meeting = new Meeting(\n        {\n          userId: this.webex.internal.device.userId,\n          deviceUrl: this.webex.internal.device.url,\n          orgId: this.webex.internal.device.orgId,\n          roapSeq: 0,\n          locus: type === _LOCUS_ID_ ? destination : null // pass the locus object if present\n        },\n        {\n          parent: this.webex\n        }\n      );\n\n      this.meetingCollection.set(meeting);\n\n      try {\n        const info = await this.meetingInfo.fetchMeetingInfo(MeetingsUtil.extractDestination(destination, type), type);\n\n        meeting.parseMeetingInfo(info);\n        meeting.meetingInfo = info ? info.body : null;\n      }\n      catch (err) {\n        // if there is no meeting info we assume its a 1:1 call or wireless share\n        LoggerProxy.logger.info(`Meetings:index#createMeeting --> Info Unable to fetch meeting info for ${destination}.`);\n        LoggerProxy.logger.info('Meetings:index#createMeeting --> Info assuming this destination is a 1:1 or wireless share');\n        LoggerProxy.logger.debug(`Meetings:index#createMeeting --> Debug ${err} fetching /meetingInfo for creation.`);\n        // We need to save this info for future reference\n        meeting.destination = destination;\n      }\n      finally {\n        // For type LOCUS_ID we need to parse the locus object to get the information\n        // about the caller and callee\n        // Meeting Added event will be created in `handleLocusEvent`\n        if (type !== _LOCUS_ID_) {\n          if (!meeting.sipUri) {\n            meeting.setSipUri(destination);\n          }\n\n          // TODO: check if we have to move this to parser\n          const meetingAddedType = MeetingsUtil.getMeetingAddedType(type);\n\n          // We typically shouldn't need to trigger both and event and return a promise.\n          // Is this a special case? We want to make the public API usage as simple as possible.\n          Trigger.trigger(\n            this,\n            {\n              file: 'meetings',\n              function: 'createMeeting'\n            },\n            EVENT_TRIGGERS.MEETING_ADDED,\n            {\n              meeting,\n              type: meetingAddedType\n            }\n          );\n        }\n      }\n\n      return meeting;\n\n      // Create the meeting calling the necessary service endpoints.\n\n      // Internally, there are many more destinations:\n      //\n      // - locusID\n      // - meetingURL\n      // - globalMeetingID, e.g, *00*meetingID\n      // - meetingID\n      // - meetingURL\n      // - PSTN\n      // - phone number\n      //\n      // Our job is to determine the appropriate one\n      // and its corresponding service so that developers\n      // need only sipURL or spaceID to get a meeting\n      // and its ID, but have the option to use createWithType()\n      // and specify those types to get meetingInfo\n    }\n\n    /**\n     * get a specifc meeting given it's type matched to the value, i.e., locus url\n     * @param {String} type\n     * @param {Object} value\n     * @returns {Meeting}\n     * @public\n     * @memberof Meetings\n     */\n    getMeetingByType(type, value) {\n      return this.meetingCollection.getByKey(type, value);\n    }\n\n    /**\n     * Get all meetings.\n     * @param {object} options\n     * @param {object} options.startDate - get meetings after this start date\n     * @param {object} options.endDate - get meetings before this end date\n     * @returns {Object} All currently active meetings.\n     * @public\n     * @memberof Meetings\n     */\n    getAllMeetings(options = {}) {\n      // Options may include other parameters to filter this collection\n      // of meetings.\n      return this.meetingCollection.getAll(options);\n    }\n\n    /**\n     * syncs all the meeting from server\n     * @returns {undefined}\n     * @public\n     * @memberof Meetings\n     */\n    syncMeetings() {\n      return this.request.getActiveMeetings().then((locusArray) => {\n        const activeLocusUrl = [];\n\n        if (locusArray.loci && locusArray.loci.length > 0) {\n          locusArray.loci.forEach((locus) => {\n            activeLocusUrl.push(locus.url);\n            this.handleLocusEvent({\n              locus,\n              locusUrl: locus.url\n            });\n          });\n        }\n        if (Object.keys(this.meetingCollection.getAll()).length > 0) {\n          // Some time the mercury event is missed after mercury reconnect\n          // if sync returns no locus then clear all the meetings\n          forEach(this.meetingCollection.getAll(), (meeting) => {\n            if (!activeLocusUrl.includes(meeting.locusUrl)) {\n              this.destroy(meeting, MEETING_REMOVED_REASON.NO_MEETINGS_TO_SYNC);\n            }\n          });\n        }\n      });\n    }\n\n    /**\n     * Get all scheduled meetings.\n     * @param {object} options\n     * @param {object} options.startDate - get meetings after this start date\n     * @param {object} options.endDate - get meetings before this end date\n     * @returns {Object} All scheduled meetings.\n     * @memberof Meetings\n     */\n    getScheduledMeetings() {\n      return this.meetingCollection.getAll({scheduled: true});\n    }\n\n    /**\n     * Get the logger instance for plugin-meetings\n     * @returns {Logger}\n     */\n    getLogger() {\n      return LoggerProxy.get();\n    }\n\n    /**\n     * Get the Stats Analyzer singleton\n     * @returns {StatsAnalyzer}\n     * @public\n     * @memberof Meetings\n     */\n    getAnalyzer() {\n      return StatsAnalyzer;\n    }\n\n    /**\n     * Get the Stats Calculator singleton\n     * @returns {StatsCalculator}\n     * @public\n     * @memberof Meetings\n     */\n    getCalculator() {\n      return StatsCalculator;\n    }\n}\n"]}